'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RootFinder = exports.wrap = exports.createRenderWrapper = exports.createMountWrapper = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.mapNativeEventNames = mapNativeEventNames;
exports.propFromEvent = propFromEvent;
exports.withSetStateAllowed = withSetStateAllowed;
exports.assertDomAvailable = assertDomAvailable;
exports.displayNameOfNode = displayNameOfNode;
exports.nodeTypeFromType = nodeTypeFromType;
exports.isArrayLike = isArrayLike;
exports.flatten = flatten;
exports.ensureKeyOrUndefined = ensureKeyOrUndefined;
exports.elementToTree = elementToTree;
exports.findElement = findElement;
exports.propsWithKeysAndRef = propsWithKeysAndRef;
exports.getComponentStack = getComponentStack;
exports.simulateError = simulateError;
exports.getMaskedContext = getMaskedContext;
exports.getNodeFromRootFinder = getNodeFromRootFinder;
exports.wrapWithWrappingComponent = wrapWithWrappingComponent;
exports.getWrappingComponentMountRenderer = getWrappingComponentMountRenderer;

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _functionPrototype = require('function.prototype.name');

var _functionPrototype2 = _interopRequireDefault(_functionPrototype);

var _object3 = require('object.fromentries');

var _object4 = _interopRequireDefault(_object3);

var _createMountWrapper = require('./createMountWrapper');

var _createMountWrapper2 = _interopRequireDefault(_createMountWrapper);

var _createRenderWrapper = require('./createRenderWrapper');

var _createRenderWrapper2 = _interopRequireDefault(_createRenderWrapper);

var _wrapWithSimpleWrapper = require('./wrapWithSimpleWrapper');

var _wrapWithSimpleWrapper2 = _interopRequireDefault(_wrapWithSimpleWrapper);

var _RootFinder = require('./RootFinder');

var _RootFinder2 = _interopRequireDefault(_RootFinder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports.createMountWrapper = _createMountWrapper2['default'];
exports.createRenderWrapper = _createRenderWrapper2['default'];
exports.wrap = _wrapWithSimpleWrapper2['default'];
exports.RootFinder = _RootFinder2['default'];
function mapNativeEventNames(event) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$animation = _ref.animation,
      animation = _ref$animation === undefined ? false : _ref$animation,
      _ref$pointerEvents = _ref.pointerEvents,
      pointerEvents = _ref$pointerEvents === undefined ? false : _ref$pointerEvents,
      _ref$auxClick = _ref.auxClick,
      auxClick = _ref$auxClick === undefined ? false : _ref$auxClick;

  var nativeToReactEventMap = (0, _object2['default'])({
    compositionend: 'compositionEnd',
    compositionstart: 'compositionStart',
    compositionupdate: 'compositionUpdate',
    keydown: 'keyDown',
    keyup: 'keyUp',
    keypress: 'keyPress',
    contextmenu: 'contextMenu',
    dblclick: 'doubleClick',
    doubleclick: 'doubleClick', // kept for legacy. TODO: remove with next major.
    dragend: 'dragEnd',
    dragenter: 'dragEnter',
    dragexist: 'dragExit',
    dragleave: 'dragLeave',
    dragover: 'dragOver',
    dragstart: 'dragStart',
    mousedown: 'mouseDown',
    mousemove: 'mouseMove',
    mouseout: 'mouseOut',
    mouseover: 'mouseOver',
    mouseup: 'mouseUp',
    touchcancel: 'touchCancel',
    touchend: 'touchEnd',
    touchmove: 'touchMove',
    touchstart: 'touchStart',
    canplay: 'canPlay',
    canplaythrough: 'canPlayThrough',
    durationchange: 'durationChange',
    loadeddata: 'loadedData',
    loadedmetadata: 'loadedMetadata',
    loadstart: 'loadStart',
    ratechange: 'rateChange',
    timeupdate: 'timeUpdate',
    volumechange: 'volumeChange',
    beforeinput: 'beforeInput',
    mouseenter: 'mouseEnter',
    mouseleave: 'mouseLeave',
    transitionend: 'transitionEnd'
  }, animation && {
    animationstart: 'animationStart',
    animationiteration: 'animationIteration',
    animationend: 'animationEnd'
  }, pointerEvents && {
    pointerdown: 'pointerDown',
    pointermove: 'pointerMove',
    pointerup: 'pointerUp',
    pointercancel: 'pointerCancel',
    gotpointercapture: 'gotPointerCapture',
    lostpointercapture: 'lostPointerCapture',
    pointerenter: 'pointerEnter',
    pointerleave: 'pointerLeave',
    pointerover: 'pointerOver',
    pointerout: 'pointerOut'
  }, auxClick && {
    auxclick: 'auxClick'
  });

  return nativeToReactEventMap[event] || event;
}

// 'click' => 'onClick'
// 'mouseEnter' => 'onMouseEnter'
function propFromEvent(event) {
  var eventOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var nativeEvent = mapNativeEventNames(event, eventOptions);
  return 'on' + String(nativeEvent[0].toUpperCase()) + String(nativeEvent.slice(1));
}

function withSetStateAllowed(fn) {
  // NOTE(lmr):
  // this is currently here to circumvent a React bug where `setState()` is
  // not allowed without global being defined.
  var cleanup = false;
  if (typeof global.document === 'undefined') {
    cleanup = true;
    global.document = {};
  }
  var result = fn();
  if (cleanup) {
    // This works around a bug in node/jest in that developers aren't able to
    // delete things from global when running in a node vm.
    global.document = undefined;
    delete global.document;
  }
  return result;
}

function assertDomAvailable(feature) {
  if (!global || !global.document || !global.document.createElement) {
    throw new Error('Enzyme\'s ' + String(feature) + ' expects a DOM environment to be loaded, but found none');
  }
}

function displayNameOfNode(node) {
  if (!node) return null;

  var type = node.type;


  if (!type) return null;

  return type.displayName || (typeof type === 'function' ? (0, _functionPrototype2['default'])(type) : type.name || type);
}

function nodeTypeFromType(type) {
  if (typeof type === 'string') {
    return 'host';
  }
  if (type && type.prototype && type.prototype.isReactComponent) {
    return 'class';
  }
  return 'function';
}

function getIteratorFn(obj) {
  var iteratorFn = obj && (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && obj[Symbol.iterator] || obj['@@iterator']);

  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }

  return undefined;
}

function isIterable(obj) {
  return !!getIteratorFn(obj);
}

function isArrayLike(obj) {
  return Array.isArray(obj) || typeof obj !== 'string' && isIterable(obj);
}

function flatten(arrs) {
  // optimize for the most common case
  if (Array.isArray(arrs)) {
    return arrs.reduce(function (flatArrs, item) {
      return flatArrs.concat(isArrayLike(item) ? flatten(item) : item);
    }, []);
  }

  // fallback for arbitrary iterable children
  var flatArrs = [];

  var iteratorFn = getIteratorFn(arrs);
  var iterator = iteratorFn.call(arrs);

  var step = iterator.next();

  while (!step.done) {
    var item = step.value;
    var flatItem = void 0;

    if (isArrayLike(item)) {
      flatItem = flatten(item);
    } else {
      flatItem = item;
    }

    flatArrs = flatArrs.concat(flatItem);

    step = iterator.next();
  }

  return flatArrs;
}

function ensureKeyOrUndefined(key) {
  return key || (key === '' ? '' : undefined);
}

function elementToTree(el) {
  var recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : elementToTree;

  if (typeof recurse !== 'function' && arguments.length === 3) {
    // special case for backwards compat for `.map(elementToTree)`
    recurse = elementToTree; // eslint-disable-line no-param-reassign
  }
  if (el === null || (typeof el === 'undefined' ? 'undefined' : _typeof(el)) !== 'object' || !('type' in el)) {
    return el;
  }
  var type = el.type,
      props = el.props,
      key = el.key,
      ref = el.ref;
  var children = props.children;

  var rendered = null;
  if (isArrayLike(children)) {
    rendered = flatten(children).map(function (x) {
      return recurse(x);
    });
  } else if (typeof children !== 'undefined') {
    rendered = recurse(children);
  }

  var nodeType = nodeTypeFromType(type);

  if (nodeType === 'host' && props.dangerouslySetInnerHTML) {
    if (props.children != null) {
      var error = new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
      error.name = 'Invariant Violation';
      throw error;
    }
  }

  return {
    nodeType: nodeType,
    type: type,
    props: props,
    key: ensureKeyOrUndefined(key),
    ref: ref,
    instance: null,
    rendered: rendered
  };
}

function mapFind(arraylike, mapper, finder) {
  var found = void 0;
  var isFound = Array.prototype.find.call(arraylike, function (item) {
    found = mapper(item);
    return finder(found);
  });
  return isFound ? found : undefined;
}

function findElement(el, predicate) {
  if (el === null || (typeof el === 'undefined' ? 'undefined' : _typeof(el)) !== 'object' || !('type' in el)) {
    return undefined;
  }
  if (predicate(el)) {
    return el;
  }
  var rendered = el.rendered;

  if (isArrayLike(rendered)) {
    return mapFind(rendered, function (x) {
      return findElement(x, predicate);
    }, function (x) {
      return typeof x !== 'undefined';
    });
  }
  return findElement(rendered, predicate);
}

function propsWithKeysAndRef(node) {
  if (node.ref !== null || node.key !== null) {
    return (0, _object2['default'])({}, node.props, {
      key: node.key,
      ref: node.ref
    });
  }
  return node.props;
}

function getComponentStack(hierarchy) {
  var getNodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nodeTypeFromType;
  var getDisplayName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : displayNameOfNode;

  var tuples = hierarchy.filter(function (node) {
    return node.type !== _RootFinder2['default'];
  }).map(function (x) {
    return [getNodeType(x.type), getDisplayName(x)];
  }).concat([['class', 'WrapperComponent']]);

  return tuples.map(function (_ref2, i, arr) {
    var _ref3 = _slicedToArray(_ref2, 2),
        name = _ref3[1];

    var _ref4 = arr.slice(i + 1).find(function (_ref6) {
      var _ref7 = _slicedToArray(_ref6, 1),
          nodeType = _ref7[0];

      return nodeType !== 'host';
    }) || [],
        _ref5 = _slicedToArray(_ref4, 2),
        closestComponent = _ref5[1];

    return '\n    in ' + String(name) + (closestComponent ? ' (created by ' + String(closestComponent) + ')' : '');
  }).join('');
}

function simulateError(error, catchingInstance, rootNode, // TODO: remove `rootNode` next semver-major
hierarchy) {
  var getNodeType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : nodeTypeFromType;
  var getDisplayName = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : displayNameOfNode;
  var catchingType = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};

  var instance = catchingInstance || {};

  var componentDidCatch = instance.componentDidCatch;
  var getDerivedStateFromError = catchingType.getDerivedStateFromError;


  if (!componentDidCatch && !getDerivedStateFromError) {
    throw error;
  }

  if (getDerivedStateFromError) {
    var stateUpdate = getDerivedStateFromError.call(catchingType, error);
    instance.setState(stateUpdate);
  }

  if (componentDidCatch) {
    var componentStack = getComponentStack(hierarchy, getNodeType, getDisplayName);
    componentDidCatch.call(instance, error, { componentStack: componentStack });
  }
}

function getMaskedContext(contextTypes, unmaskedContext) {
  if (!contextTypes || !unmaskedContext) {
    return {};
  }
  return (0, _object4['default'])(Object.keys(contextTypes).map(function (key) {
    return [key, unmaskedContext[key]];
  }));
}

function getNodeFromRootFinder(isCustomComponent, tree, options) {
  if (!isCustomComponent(options.wrappingComponent)) {
    return tree.rendered;
  }
  var rootFinder = findElement(tree, function (node) {
    return node.type === _RootFinder2['default'];
  });
  if (!rootFinder) {
    throw new Error('`wrappingComponent` must render its children!');
  }
  return rootFinder.rendered;
}

function wrapWithWrappingComponent(createElement, node, options) {
  var wrappingComponent = options.wrappingComponent,
      wrappingComponentProps = options.wrappingComponentProps;

  if (!wrappingComponent) {
    return node;
  }
  return createElement(wrappingComponent, wrappingComponentProps, createElement(_RootFinder2['default'], null, node));
}

function getWrappingComponentMountRenderer(_ref8) {
  var toTree = _ref8.toTree,
      getMountWrapperInstance = _ref8.getMountWrapperInstance;

  return {
    getNode: function () {
      function getNode() {
        var instance = getMountWrapperInstance();
        return instance ? toTree(instance).rendered : null;
      }

      return getNode;
    }(),
    render: function () {
      function render(el, context, callback) {
        var instance = getMountWrapperInstance();
        if (!instance) {
          throw new Error('The wrapping component may not be updated if the root is unmounted.');
        }
        return instance.setWrappingComponentProps(el.props, callback);
      }

      return render;
    }()
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9VdGlscy5qcyJdLCJuYW1lcyI6WyJtYXBOYXRpdmVFdmVudE5hbWVzIiwicHJvcEZyb21FdmVudCIsIndpdGhTZXRTdGF0ZUFsbG93ZWQiLCJhc3NlcnREb21BdmFpbGFibGUiLCJkaXNwbGF5TmFtZU9mTm9kZSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJpc0FycmF5TGlrZSIsImZsYXR0ZW4iLCJlbnN1cmVLZXlPclVuZGVmaW5lZCIsImVsZW1lbnRUb1RyZWUiLCJmaW5kRWxlbWVudCIsInByb3BzV2l0aEtleXNBbmRSZWYiLCJnZXRDb21wb25lbnRTdGFjayIsInNpbXVsYXRlRXJyb3IiLCJnZXRNYXNrZWRDb250ZXh0IiwiZ2V0Tm9kZUZyb21Sb290RmluZGVyIiwid3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudCIsImdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlciIsImNyZWF0ZU1vdW50V3JhcHBlciIsImNyZWF0ZVJlbmRlcldyYXBwZXIiLCJ3cmFwIiwiUm9vdEZpbmRlciIsImV2ZW50IiwiYW5pbWF0aW9uIiwicG9pbnRlckV2ZW50cyIsImF1eENsaWNrIiwibmF0aXZlVG9SZWFjdEV2ZW50TWFwIiwiY29tcG9zaXRpb25lbmQiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb251cGRhdGUiLCJrZXlkb3duIiwia2V5dXAiLCJrZXlwcmVzcyIsImNvbnRleHRtZW51IiwiZGJsY2xpY2siLCJkb3VibGVjbGljayIsImRyYWdlbmQiLCJkcmFnZW50ZXIiLCJkcmFnZXhpc3QiLCJkcmFnbGVhdmUiLCJkcmFnb3ZlciIsImRyYWdzdGFydCIsIm1vdXNlZG93biIsIm1vdXNlbW92ZSIsIm1vdXNlb3V0IiwibW91c2VvdmVyIiwibW91c2V1cCIsInRvdWNoY2FuY2VsIiwidG91Y2hlbmQiLCJ0b3VjaG1vdmUiLCJ0b3VjaHN0YXJ0IiwiY2FucGxheSIsImNhbnBsYXl0aHJvdWdoIiwiZHVyYXRpb25jaGFuZ2UiLCJsb2FkZWRkYXRhIiwibG9hZGVkbWV0YWRhdGEiLCJsb2Fkc3RhcnQiLCJyYXRlY2hhbmdlIiwidGltZXVwZGF0ZSIsInZvbHVtZWNoYW5nZSIsImJlZm9yZWlucHV0IiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJ0cmFuc2l0aW9uZW5kIiwiYW5pbWF0aW9uc3RhcnQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25lbmQiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmNhbmNlbCIsImdvdHBvaW50ZXJjYXB0dXJlIiwibG9zdHBvaW50ZXJjYXB0dXJlIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm92ZXIiLCJwb2ludGVyb3V0IiwiYXV4Y2xpY2siLCJldmVudE9wdGlvbnMiLCJuYXRpdmVFdmVudCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJmbiIsImNsZWFudXAiLCJnbG9iYWwiLCJkb2N1bWVudCIsInJlc3VsdCIsInVuZGVmaW5lZCIsImZlYXR1cmUiLCJjcmVhdGVFbGVtZW50IiwiRXJyb3IiLCJub2RlIiwidHlwZSIsImRpc3BsYXlOYW1lIiwibmFtZSIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJnZXRJdGVyYXRvckZuIiwib2JqIiwiaXRlcmF0b3JGbiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNJdGVyYWJsZSIsIkFycmF5IiwiaXNBcnJheSIsImFycnMiLCJyZWR1Y2UiLCJmbGF0QXJycyIsIml0ZW0iLCJjb25jYXQiLCJjYWxsIiwic3RlcCIsIm5leHQiLCJkb25lIiwidmFsdWUiLCJmbGF0SXRlbSIsImtleSIsImVsIiwicmVjdXJzZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInByb3BzIiwicmVmIiwiY2hpbGRyZW4iLCJyZW5kZXJlZCIsIm1hcCIsIngiLCJub2RlVHlwZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiZXJyb3IiLCJpbnN0YW5jZSIsIm1hcEZpbmQiLCJhcnJheWxpa2UiLCJtYXBwZXIiLCJmaW5kZXIiLCJmb3VuZCIsImlzRm91bmQiLCJmaW5kIiwicHJlZGljYXRlIiwiaGllcmFyY2h5IiwiZ2V0Tm9kZVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsInR1cGxlcyIsImZpbHRlciIsImkiLCJhcnIiLCJjbG9zZXN0Q29tcG9uZW50Iiwiam9pbiIsImNhdGNoaW5nSW5zdGFuY2UiLCJyb290Tm9kZSIsImNhdGNoaW5nVHlwZSIsImNvbXBvbmVudERpZENhdGNoIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwic3RhdGVVcGRhdGUiLCJzZXRTdGF0ZSIsImNvbXBvbmVudFN0YWNrIiwiY29udGV4dFR5cGVzIiwidW5tYXNrZWRDb250ZXh0IiwiT2JqZWN0Iiwia2V5cyIsImlzQ3VzdG9tQ29tcG9uZW50IiwidHJlZSIsIm9wdGlvbnMiLCJ3cmFwcGluZ0NvbXBvbmVudCIsInJvb3RGaW5kZXIiLCJ3cmFwcGluZ0NvbXBvbmVudFByb3BzIiwidG9UcmVlIiwiZ2V0TW91bnRXcmFwcGVySW5zdGFuY2UiLCJnZXROb2RlIiwicmVuZGVyIiwiY29udGV4dCIsImNhbGxiYWNrIiwic2V0V3JhcHBpbmdDb21wb25lbnRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUFjZ0JBLG1CLEdBQUFBLG1CO1FBc0VBQyxhLEdBQUFBLGE7UUFLQUMsbUIsR0FBQUEsbUI7UUFtQkFDLGtCLEdBQUFBLGtCO1FBTUFDLGlCLEdBQUFBLGlCO1FBVUFDLGdCLEdBQUFBLGdCO1FBMkJBQyxXLEdBQUFBLFc7UUFJQUMsTyxHQUFBQSxPO1FBbUNBQyxvQixHQUFBQSxvQjtRQUlBQyxhLEdBQUFBLGE7UUFvREFDLFcsR0FBQUEsVztRQWNBQyxtQixHQUFBQSxtQjtRQVdBQyxpQixHQUFBQSxpQjtRQW1CQUMsYSxHQUFBQSxhO1FBOEJBQyxnQixHQUFBQSxnQjtRQU9BQyxxQixHQUFBQSxxQjtRQVdBQyx5QixHQUFBQSx5QjtRQVlBQyxpQyxHQUFBQSxpQzs7Ozs7O0FBOVZoQjs7OztBQUNBOzs7O0FB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RUFBZ0NzRSxJQUFoQyxDQUhLLENBQVA7QUFLRDs7QUFFTSxTQUFTMUUsaUNBQVQsUUFBZ0Y7QUFBQSxNQUFuQ3FKLE1BQW1DLFNBQW5DQSxNQUFtQztBQUFBLE1BQTNCQyx1QkFBMkIsU0FBM0JBLHVCQUEyQjs7QUFDckYsU0FBTztBQUNMQyxXQURLO0FBQUEseUJBQ0s7QUFDUixZQUFNdEMsV0FBV3FDLHlCQUFqQjtBQUNBLGVBQU9yQyxXQUFXb0MsT0FBT3BDLFFBQVAsRUFBaUJOLFFBQTVCLEdBQXVDLElBQTlDO0FBQ0Q7O0FBSkk7QUFBQTtBQUtMNkMsVUFMSztBQUFBLHNCQUtFcEQsRUFMRixFQUtNcUQsT0FMTixFQUtlQyxRQUxmLEVBS3lCO0FBQzVCLFlBQU16QyxXQUFXcUMseUJBQWpCO0FBQ0EsWUFBSSxDQUFDckMsUUFBTCxFQUFlO0FBQ2IsZ0JBQU0sSUFBSXhDLEtBQUosQ0FBVSxxRUFBVixDQUFOO0FBQ0Q7QUFDRCxlQUFPd0MsU0FBUzBDLHlCQUFULENBQW1DdkQsR0FBR0ksS0FBdEMsRUFBNkNrRCxRQUE3QyxDQUFQO0FBQ0Q7O0FBWEk7QUFBQTtBQUFBLEdBQVA7QUFhRCIsImZpbGUiOiJVdGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmdW5jdGlvbk5hbWUgZnJvbSAnZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUnO1xuaW1wb3J0IGZyb21FbnRyaWVzIGZyb20gJ29iamVjdC5mcm9tZW50cmllcyc7XG5pbXBvcnQgY3JlYXRlTW91bnRXcmFwcGVyIGZyb20gJy4vY3JlYXRlTW91bnRXcmFwcGVyJztcbmltcG9ydCBjcmVhdGVSZW5kZXJXcmFwcGVyIGZyb20gJy4vY3JlYXRlUmVuZGVyV3JhcHBlcic7XG5pbXBvcnQgd3JhcCBmcm9tICcuL3dyYXBXaXRoU2ltcGxlV3JhcHBlcic7XG5pbXBvcnQgUm9vdEZpbmRlciBmcm9tICcuL1Jvb3RGaW5kZXInO1xuXG5leHBvcnQge1xuICBjcmVhdGVNb3VudFdyYXBwZXIsXG4gIGNyZWF0ZVJlbmRlcldyYXBwZXIsXG4gIHdyYXAsXG4gIFJvb3RGaW5kZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwTmF0aXZlRXZlbnROYW1lcyhldmVudCwge1xuICBhbmltYXRpb24gPSBmYWxzZSwgLy8gc2hvdWxkIGJlIHRydWUgZm9yIFJlYWN0IDE1K1xuICBwb2ludGVyRXZlbnRzID0gZmFsc2UsIC8vIHNob3VsZCBiZSB0cnVlIGZvciBSZWFjdCAxNi40K1xuICBhdXhDbGljayA9IGZhbHNlLCAvLyBzaG91bGQgYmUgdHJ1ZSBmb3IgUmVhY3QgMTYuNStcbn0gPSB7fSkge1xuICBjb25zdCBuYXRpdmVUb1JlYWN0RXZlbnRNYXAgPSB7XG4gICAgY29tcG9zaXRpb25lbmQ6ICdjb21wb3NpdGlvbkVuZCcsXG4gICAgY29tcG9zaXRpb25zdGFydDogJ2NvbXBvc2l0aW9uU3RhcnQnLFxuICAgIGNvbXBvc2l0aW9udXBkYXRlOiAnY29tcG9zaXRpb25VcGRhdGUnLFxuICAgIGtleWRvd246ICdrZXlEb3duJyxcbiAgICBrZXl1cDogJ2tleVVwJyxcbiAgICBrZXlwcmVzczogJ2tleVByZXNzJyxcbiAgICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgICBkYmxjbGljazogJ2RvdWJsZUNsaWNrJyxcbiAgICBkb3VibGVjbGljazogJ2RvdWJsZUNsaWNrJywgLy8ga2VwdCBmb3IgbGVnYWN5LiBUT0RPOiByZW1vdmUgd2l0aCBuZXh0IG1ham9yLlxuICAgIGRyYWdlbmQ6ICdkcmFnRW5kJyxcbiAgICBkcmFnZW50ZXI6ICdkcmFnRW50ZXInLFxuICAgIGRyYWdleGlzdDogJ2RyYWdFeGl0JyxcbiAgICBkcmFnbGVhdmU6ICdkcmFnTGVhdmUnLFxuICAgIGRyYWdvdmVyOiAnZHJhZ092ZXInLFxuICAgIGRyYWdzdGFydDogJ2RyYWdTdGFydCcsXG4gICAgbW91c2Vkb3duOiAnbW91c2VEb3duJyxcbiAgICBtb3VzZW1vdmU6ICdtb3VzZU1vdmUnLFxuICAgIG1vdXNlb3V0OiAnbW91c2VPdXQnLFxuICAgIG1vdXNlb3ZlcjogJ21vdXNlT3ZlcicsXG4gICAgbW91c2V1cDogJ21vdXNlVXAnLFxuICAgIHRvdWNoY2FuY2VsOiAndG91Y2hDYW5jZWwnLFxuICAgIHRvdWNoZW5kOiAndG91Y2hFbmQnLFxuICAgIHRvdWNobW92ZTogJ3RvdWNoTW92ZScsXG4gICAgdG91Y2hzdGFydDogJ3RvdWNoU3RhcnQnLFxuICAgIGNhbnBsYXk6ICdjYW5QbGF5JyxcbiAgICBjYW5wbGF5dGhyb3VnaDogJ2NhblBsYXlUaHJvdWdoJyxcbiAgICBkdXJhdGlvbmNoYW5nZTogJ2R1cmF0aW9uQ2hhbmdlJyxcbiAgICBsb2FkZWRkYXRhOiAnbG9hZGVkRGF0YScsXG4gICAgbG9hZGVkbWV0YWRhdGE6ICdsb2FkZWRNZXRhZGF0YScsXG4gICAgbG9hZHN0YXJ0OiAnbG9hZFN0YXJ0JyxcbiAgICByYXRlY2hhbmdlOiAncmF0ZUNoYW5nZScsXG4gICAgdGltZXVwZGF0ZTogJ3RpbWVVcGRhdGUnLFxuICAgIHZvbHVtZWNoYW5nZTogJ3ZvbHVtZUNoYW5nZScsXG4gICAgYmVmb3JlaW5wdXQ6ICdiZWZvcmVJbnB1dCcsXG4gICAgbW91c2VlbnRlcjogJ21vdXNlRW50ZXInLFxuICAgIG1vdXNlbGVhdmU6ICdtb3VzZUxlYXZlJyxcbiAgICB0cmFuc2l0aW9uZW5kOiAndHJhbnNpdGlvbkVuZCcsXG4gICAgLi4uKGFuaW1hdGlvbiAmJiB7XG4gICAgICBhbmltYXRpb25zdGFydDogJ2FuaW1hdGlvblN0YXJ0JyxcbiAgICAgIGFuaW1hdGlvbml0ZXJhdGlvbjogJ2FuaW1hdGlvbkl0ZXJhdGlvbicsXG4gICAgICBhbmltYXRpb25lbmQ6ICdhbmltYXRpb25FbmQnLFxuICAgIH0pLFxuICAgIC4uLihwb2ludGVyRXZlbnRzICYmIHtcbiAgICAgIHBvaW50ZXJkb3duOiAncG9pbnRlckRvd24nLFxuICAgICAgcG9pbnRlcm1vdmU6ICdwb2ludGVyTW92ZScsXG4gICAgICBwb2ludGVydXA6ICdwb2ludGVyVXAnLFxuICAgICAgcG9pbnRlcmNhbmNlbDogJ3BvaW50ZXJDYW5jZWwnLFxuICAgICAgZ290cG9pbnRlcmNhcHR1cmU6ICdnb3RQb2ludGVyQ2FwdHVyZScsXG4gICAgICBsb3N0cG9pbnRlcmNhcHR1cmU6ICdsb3N0UG9pbnRlckNhcHR1cmUnLFxuICAgICAgcG9pbnRlcmVudGVyOiAncG9pbnRlckVudGVyJyxcbiAgICAgIHBvaW50ZXJsZWF2ZTogJ3BvaW50ZXJMZWF2ZScsXG4gICAgICBwb2ludGVyb3ZlcjogJ3BvaW50ZXJPdmVyJyxcbiAgICAgIHBvaW50ZXJvdXQ6ICdwb2ludGVyT3V0JyxcbiAgICB9KSxcbiAgICAuLi4oYXV4Q2xpY2sgJiYge1xuICAgICAgYXV4Y2xpY2s6ICdhdXhDbGljaycsXG4gICAgfSksXG4gIH07XG5cbiAgcmV0dXJuIG5hdGl2ZVRvUmVhY3RFdmVudE1hcFtldmVudF0gfHwgZXZlbnQ7XG59XG5cbi8vICdjbGljaycgPT4gJ29uQ2xpY2snXG4vLyAnbW91c2VFbnRlcicgPT4gJ29uTW91c2VFbnRlcidcbmV4cG9ydCBmdW5jdGlvbiBwcm9wRnJvbUV2ZW50KGV2ZW50LCBldmVudE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBuYXRpdmVFdmVudCA9IG1hcE5hdGl2ZUV2ZW50TmFtZXMoZXZlbnQsIGV2ZW50T3B0aW9ucyk7XG4gIHJldHVybiBgb24ke25hdGl2ZUV2ZW50WzBdLnRvVXBwZXJDYXNlKCl9JHtuYXRpdmVFdmVudC5zbGljZSgxKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFNldFN0YXRlQWxsb3dlZChmbikge1xuICAvLyBOT1RFKGxtcik6XG4gIC8vIHRoaXMgaXMgY3VycmVudGx5IGhlcmUgdG8gY2lyY3VtdmVudCBhIFJlYWN0IGJ1ZyB3aGVyZSBgc2V0U3RhdGUoKWAgaXNcbiAgLy8gbm90IGFsbG93ZWQgd2l0aG91dCBnbG9iYWwgYmVpbmcgZGVmaW5lZC5cbiAgbGV0IGNsZWFudXAgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2xlYW51cCA9IHRydWU7XG4gICAgZ2xvYmFsLmRvY3VtZW50ID0ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgaWYgKGNsZWFudXApIHtcbiAgICAvLyBUaGlzIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBub2RlL2plc3QgaW4gdGhhdCBkZXZlbG9wZXJzIGFyZW4ndCBhYmxlIHRvXG4gICAgLy8gZGVsZXRlIHRoaW5ncyBmcm9tIGdsb2JhbCB3aGVuIHJ1bm5pbmcgaW4gYSBub2RlIHZtLlxuICAgIGdsb2JhbC5kb2N1bWVudCA9IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgZ2xvYmFsLmRvY3VtZW50O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREb21BdmFpbGFibGUoZmVhdHVyZSkge1xuICBpZiAoIWdsb2JhbCB8fCAhZ2xvYmFsLmRvY3VtZW50IHx8ICFnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lJ3MgJHtmZWF0dXJlfSBleHBlY3RzIGEgRE9NIGVudmlyb25tZW50IHRvIGJlIGxvYWRlZCwgYnV0IGZvdW5kIG5vbmVgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHsgdHlwZSB9ID0gbm9kZTtcblxuICBpZiAoIXR5cGUpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uTmFtZSh0eXBlKSA6IHR5cGUubmFtZSB8fCB0eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVUeXBlRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICdob3N0JztcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICdjbGFzcyc7XG4gIH1cbiAgcmV0dXJuICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4ob2JqKSB7XG4gIGNvbnN0IGl0ZXJhdG9yRm4gPSBvYmogJiYgKFxuICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdKVxuICAgIHx8IG9ialsnQEBpdGVyYXRvciddXG4gICk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaikge1xuICByZXR1cm4gISFnZXRJdGVyYXRvckZuKG9iaik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fCAodHlwZW9mIG9iaiAhPT0gJ3N0cmluZycgJiYgaXNJdGVyYWJsZShvYmopKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJycykge1xuICAvLyBvcHRpbWl6ZSBmb3IgdGhlIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJycykpIHtcbiAgICByZXR1cm4gYXJycy5yZWR1Y2UoXG4gICAgICAoZmxhdEFycnMsIGl0ZW0pID0+IGZsYXRBcnJzLmNvbmNhdChpc0FycmF5TGlrZShpdGVtKSA/IGZsYXR0ZW4oaXRlbSkgOiBpdGVtKSxcbiAgICAgIFtdLFxuICAgICk7XG4gIH1cblxuICAvLyBmYWxsYmFjayBmb3IgYXJiaXRyYXJ5IGl0ZXJhYmxlIGNoaWxkcmVuXG4gIGxldCBmbGF0QXJycyA9IFtdO1xuXG4gIGNvbnN0IGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGFycnMpO1xuICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChhcnJzKTtcblxuICBsZXQgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgIGNvbnN0IGl0ZW0gPSBzdGVwLnZhbHVlO1xuICAgIGxldCBmbGF0SXRlbTtcblxuICAgIGlmIChpc0FycmF5TGlrZShpdGVtKSkge1xuICAgICAgZmxhdEl0ZW0gPSBmbGF0dGVuKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0SXRlbSA9IGl0ZW07XG4gICAgfVxuXG4gICAgZmxhdEFycnMgPSBmbGF0QXJycy5jb25jYXQoZmxhdEl0ZW0pO1xuXG4gICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBmbGF0QXJycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUtleU9yVW5kZWZpbmVkKGtleSkge1xuICByZXR1cm4ga2V5IHx8IChrZXkgPT09ICcnID8gJycgOiB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudFRvVHJlZShlbCwgcmVjdXJzZSA9IGVsZW1lbnRUb1RyZWUpIHtcbiAgaWYgKHR5cGVvZiByZWN1cnNlICE9PSAnZnVuY3Rpb24nICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGJhY2t3YXJkcyBjb21wYXQgZm9yIGAubWFwKGVsZW1lbnRUb1RyZWUpYFxuICAgIHJlY3Vyc2UgPSBlbGVtZW50VG9UcmVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIH1cbiAgaWYgKGVsID09PSBudWxsIHx8IHR5cGVvZiBlbCAhPT0gJ29iamVjdCcgfHwgISgndHlwZScgaW4gZWwpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleSxcbiAgICByZWYsXG4gIH0gPSBlbDtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIGxldCByZW5kZXJlZCA9IG51bGw7XG4gIGlmIChpc0FycmF5TGlrZShjaGlsZHJlbikpIHtcbiAgICByZW5kZXJlZCA9IGZsYXR0ZW4oY2hpbGRyZW4pLm1hcCh4ID0+IHJlY3Vyc2UoeCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZW5kZXJlZCA9IHJlY3Vyc2UoY2hpbGRyZW4pO1xuICB9XG5cbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlVHlwZUZyb21UeXBlKHR5cGUpO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gJ2hvc3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSB7XG4gICAgaWYgKHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGVUeXBlLFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChrZXkpLFxuICAgIHJlZixcbiAgICBpbnN0YW5jZTogbnVsbCxcbiAgICByZW5kZXJlZCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwRmluZChhcnJheWxpa2UsIG1hcHBlciwgZmluZGVyKSB7XG4gIGxldCBmb3VuZDtcbiAgY29uc3QgaXNGb3VuZCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoYXJyYXlsaWtlLCAoaXRlbSkgPT4ge1xuICAgIGZvdW5kID0gbWFwcGVyKGl0ZW0pO1xuICAgIHJldHVybiBmaW5kZXIoZm91bmQpO1xuICB9KTtcbiAgcmV0dXJuIGlzRm91bmQgPyBmb3VuZCA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbGVtZW50KGVsLCBwcmVkaWNhdGUpIHtcbiAgaWYgKGVsID09PSBudWxsIHx8IHR5cGVvZiBlbCAhPT0gJ29iamVjdCcgfHwgISgndHlwZScgaW4gZWwpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAocHJlZGljYXRlKGVsKSkge1xuICAgIHJldHVybiBlbDtcbiAgfVxuICBjb25zdCB7IHJlbmRlcmVkIH0gPSBlbDtcbiAgaWYgKGlzQXJyYXlMaWtlKHJlbmRlcmVkKSkge1xuICAgIHJldHVybiBtYXBGaW5kKHJlbmRlcmVkLCB4ID0+IGZpbmRFbGVtZW50KHgsIHByZWRpY2F0ZSksIHggPT4gdHlwZW9mIHggIT09ICd1bmRlZmluZWQnKTtcbiAgfVxuICByZXR1cm4gZmluZEVsZW1lbnQocmVuZGVyZWQsIHByZWRpY2F0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc1dpdGhLZXlzQW5kUmVmKG5vZGUpIHtcbiAgaWYgKG5vZGUucmVmICE9PSBudWxsIHx8IG5vZGUua2V5ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm5vZGUucHJvcHMsXG4gICAgICBrZXk6IG5vZGUua2V5LFxuICAgICAgcmVmOiBub2RlLnJlZixcbiAgICB9O1xuICB9XG4gIHJldHVybiBub2RlLnByb3BzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50U3RhY2soXG4gIGhpZXJhcmNoeSxcbiAgZ2V0Tm9kZVR5cGUgPSBub2RlVHlwZUZyb21UeXBlLFxuICBnZXREaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlLFxuKSB7XG4gIGNvbnN0IHR1cGxlcyA9IGhpZXJhcmNoeS5maWx0ZXIobm9kZSA9PiBub2RlLnR5cGUgIT09IFJvb3RGaW5kZXIpLm1hcCh4ID0+IFtcbiAgICBnZXROb2RlVHlwZSh4LnR5cGUpLFxuICAgIGdldERpc3BsYXlOYW1lKHgpLFxuICBdKS5jb25jYXQoW1tcbiAgICAnY2xhc3MnLFxuICAgICdXcmFwcGVyQ29tcG9uZW50JyxcbiAgXV0pO1xuXG4gIHJldHVybiB0dXBsZXMubWFwKChbLCBuYW1lXSwgaSwgYXJyKSA9PiB7XG4gICAgY29uc3QgWywgY2xvc2VzdENvbXBvbmVudF0gPSBhcnIuc2xpY2UoaSArIDEpLmZpbmQoKFtub2RlVHlwZV0pID0+IG5vZGVUeXBlICE9PSAnaG9zdCcpIHx8IFtdO1xuICAgIHJldHVybiBgXFxuICAgIGluICR7bmFtZX0ke2Nsb3Nlc3RDb21wb25lbnQgPyBgIChjcmVhdGVkIGJ5ICR7Y2xvc2VzdENvbXBvbmVudH0pYCA6ICcnfWA7XG4gIH0pLmpvaW4oJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2ltdWxhdGVFcnJvcihcbiAgZXJyb3IsXG4gIGNhdGNoaW5nSW5zdGFuY2UsXG4gIHJvb3ROb2RlLCAvLyBUT0RPOiByZW1vdmUgYHJvb3ROb2RlYCBuZXh0IHNlbXZlci1tYWpvclxuICBoaWVyYXJjaHksXG4gIGdldE5vZGVUeXBlID0gbm9kZVR5cGVGcm9tVHlwZSxcbiAgZ2V0RGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZSxcbiAgY2F0Y2hpbmdUeXBlID0ge30sXG4pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjYXRjaGluZ0luc3RhbmNlIHx8IHt9O1xuXG4gIGNvbnN0IHsgY29tcG9uZW50RGlkQ2F0Y2ggfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHsgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIH0gPSBjYXRjaGluZ1R5cGU7XG5cbiAgaWYgKCFjb21wb25lbnREaWRDYXRjaCAmJiAhZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZiAoZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgY29uc3Qgc3RhdGVVcGRhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IuY2FsbChjYXRjaGluZ1R5cGUsIGVycm9yKTtcbiAgICBpbnN0YW5jZS5zZXRTdGF0ZShzdGF0ZVVwZGF0ZSk7XG4gIH1cblxuICBpZiAoY29tcG9uZW50RGlkQ2F0Y2gpIHtcbiAgICBjb25zdCBjb21wb25lbnRTdGFjayA9IGdldENvbXBvbmVudFN0YWNrKGhpZXJhcmNoeSwgZ2V0Tm9kZVR5cGUsIGdldERpc3BsYXlOYW1lKTtcbiAgICBjb21wb25lbnREaWRDYXRjaC5jYWxsKGluc3RhbmNlLCBlcnJvciwgeyBjb21wb25lbnRTdGFjayB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dChjb250ZXh0VHlwZXMsIHVubWFza2VkQ29udGV4dCkge1xuICBpZiAoIWNvbnRleHRUeXBlcyB8fCAhdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBmcm9tRW50cmllcyhPYmplY3Qua2V5cyhjb250ZXh0VHlwZXMpLm1hcChrZXkgPT4gW2tleSwgdW5tYXNrZWRDb250ZXh0W2tleV1dKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlRnJvbVJvb3RGaW5kZXIoaXNDdXN0b21Db21wb25lbnQsIHRyZWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudChvcHRpb25zLndyYXBwaW5nQ29tcG9uZW50KSkge1xuICAgIHJldHVybiB0cmVlLnJlbmRlcmVkO1xuICB9XG4gIGNvbnN0IHJvb3RGaW5kZXIgPSBmaW5kRWxlbWVudCh0cmVlLCBub2RlID0+IG5vZGUudHlwZSA9PT0gUm9vdEZpbmRlcik7XG4gIGlmICghcm9vdEZpbmRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYHdyYXBwaW5nQ29tcG9uZW50YCBtdXN0IHJlbmRlciBpdHMgY2hpbGRyZW4hJyk7XG4gIH1cbiAgcmV0dXJuIHJvb3RGaW5kZXIucmVuZGVyZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KGNyZWF0ZUVsZW1lbnQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB3cmFwcGluZ0NvbXBvbmVudCwgd3JhcHBpbmdDb21wb25lbnRQcm9wcyB9ID0gb3B0aW9ucztcbiAgaWYgKCF3cmFwcGluZ0NvbXBvbmVudCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIHdyYXBwaW5nQ29tcG9uZW50LFxuICAgIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMsXG4gICAgY3JlYXRlRWxlbWVudChSb290RmluZGVyLCBudWxsLCBub2RlKSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcih7IHRvVHJlZSwgZ2V0TW91bnRXcmFwcGVySW5zdGFuY2UgfSkge1xuICByZXR1cm4ge1xuICAgIGdldE5vZGUoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGdldE1vdW50V3JhcHBlckluc3RhbmNlKCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UgPyB0b1RyZWUoaW5zdGFuY2UpLnJlbmRlcmVkIDogbnVsbDtcbiAgICB9LFxuICAgIHJlbmRlcihlbCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0TW91bnRXcmFwcGVySW5zdGFuY2UoKTtcbiAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgd3JhcHBpbmcgY29tcG9uZW50IG1heSBub3QgYmUgdXBkYXRlZCBpZiB0aGUgcm9vdCBpcyB1bm1vdW50ZWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2Uuc2V0V3JhcHBpbmdDb21wb25lbnRQcm9wcyhlbC5wcm9wcywgY2FsbGJhY2spO1xuICAgIH0sXG4gIH07XG59XG4iXX0=
//# sourceMappingURL=Utils.js.map