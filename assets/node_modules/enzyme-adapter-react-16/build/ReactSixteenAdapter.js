'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _shallow = require('react-test-renderer/shallow');

var _shallow2 = _interopRequireDefault(_shallow);

var _package = require('react-test-renderer/package.json');

var _testUtils = require('react-dom/test-utils');

var _testUtils2 = _interopRequireDefault(_testUtils);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _checkPropTypes2 = require('prop-types/checkPropTypes');

var _checkPropTypes3 = _interopRequireDefault(_checkPropTypes2);

var _reactIs = require('react-is');

var _enzyme = require('enzyme');

var _Utils = require('enzyme/build/Utils');

var _enzymeAdapterUtils = require('enzyme-adapter-utils');

var _findCurrentFiberUsingSlowPath = require('./findCurrentFiberUsingSlowPath');

var _findCurrentFiberUsingSlowPath2 = _interopRequireDefault(_findCurrentFiberUsingSlowPath);

var _detectFiberTags = require('./detectFiberTags');

var _detectFiberTags2 = _interopRequireDefault(_detectFiberTags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-use-before-define: 0 */

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved


var is164 = !!_testUtils2['default'].Simulate.touchStart; // 16.4+
var is165 = !!_testUtils2['default'].Simulate.auxClick; // 16.5+
var is166 = is165 && !_react2['default'].unstable_AsyncMode; // 16.6+
var is168 = is166 && typeof _testUtils2['default'].act === 'function';

var hasShouldComponentUpdateBug = _semver2['default'].satisfies(_package.version, '< 16.8');

// Lazily populated if DOM is available.
var FiberTags = null;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;
  while (node != null) {
    array.push(node);
    node = node.sibling;
  }
  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{ i: 0, array: arr }];
  while (stack.length) {
    var n = stack.pop();
    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;
      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({ i: 0, array: el });
        break;
      }
      result.push(el);
    }
  }
  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;

  var props = { children: children, containerInfo: containerInfo };

  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  }
  // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps
  var node = (0, _findCurrentFiberUsingSlowPath2['default'])(vnode);
  switch (node.tag) {
    case FiberTags.HostRoot:
      return childrenToTree(node.child);
    case FiberTags.HostPortal:
      {
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;

        var props = { containerInfo: containerInfo, children: children };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    case FiberTags.ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };
    case FiberTags.FunctionalComponent:
      return {
        nodeType: 'function',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };
    case FiberTags.MemoClass:
      return {
        nodeType: 'class',
        type: node.elementType.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child.child)
      };
    case FiberTags.MemoSFC:
      {
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));
        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }
        return {
          nodeType: 'function',
          type: node.elementType,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: renderedNodes
        };
      }
    case FiberTags.HostComponent:
      {
        var _renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));
        if (_renderedNodes.length === 0) {
          _renderedNodes = [node.memoizedProps.children];
        }
        return {
          nodeType: 'host',
          type: node.type,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: _renderedNodes
        };
      }
    case FiberTags.HostText:
      return node.memoizedProps;
    case FiberTags.Fragment:
    case FiberTags.Mode:
    case FiberTags.ContextProvider:
    case FiberTags.ContextConsumer:
      return childrenToTree(node.child);
    case FiberTags.Profiler:
    case FiberTags.ForwardRef:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: (0, _object2['default'])({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    default:
      throw new Error('Enzyme Internal Error: unknown node with tag ' + String(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }
  var children = nodeAndSiblingsArray(node);
  if (children.length === 0) {
    return null;
  }
  if (children.length === 1) {
    return _toTree(children[0]);
  }
  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;
  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  }
  // if the SFC returned null effectively, there is no host node.
  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom2['default'].findDOMNode(item.instance);
    return null;
  };
  if (Array.isArray(node)) {
    return node.map(mapper);
  }
  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }
  return mapper(node);
}

var eventOptions = {
  animation: true,
  pointerEvents: is164,
  auxClick: is165
};

function getEmptyStateValue() {
  // this handles a bug in React 16.0 - 16.2
  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459
  // also see https://github.com/facebook/react/pull/11965

  // eslint-disable-next-line react/prefer-stateless-function
  var EmptyState = function (_React$Component) {
    _inherits(EmptyState, _React$Component);

    function EmptyState() {
      _classCallCheck(this, EmptyState);

      return _possibleConstructorReturn(this, (EmptyState.__proto__ || Object.getPrototypeOf(EmptyState)).apply(this, arguments));
    }

    _createClass(EmptyState, [{
      key: 'render',
      value: function () {
        function render() {
          return null;
        }

        return render;
      }()
    }]);

    return EmptyState;
  }(_react2['default'].Component);

  var testRenderer = new _shallow2['default']();
  testRenderer.render(_react2['default'].createElement(EmptyState));
  return testRenderer._instance.state;
}

function wrapAct(fn) {
  if (!is168) {
    return fn();
  }
  var returnVal = void 0;
  _testUtils2['default'].act(function () {
    returnVal = fn();
  });
  return returnVal;
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }
  if ('_currentValue' in Provider._context) {
    return Provider._context._currentValue;
  }
  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return { $$typeof: _reactIs.Element, type: type };
}

var ReactSixteenAdapter = function (_EnzymeAdapter) {
  _inherits(ReactSixteenAdapter, _EnzymeAdapter);

  function ReactSixteenAdapter() {
    _classCallCheck(this, ReactSixteenAdapter);

    var _this2 = _possibleConstructorReturn(this, (ReactSixteenAdapter.__proto__ || Object.getPrototypeOf(ReactSixteenAdapter)).call(this));

    var lifecycles = _this2.options.lifecycles;

    _this2.options = (0, _object2['default'])({}, _this2.options, {
      enableComponentDidUpdateOnSetState: true, // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: (0, _object2['default'])({}, lifecycles, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: hasShouldComponentUpdateBug
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        },
        getDerivedStateFromError: is166
      })
    });
    return _this2;
  }

  _createClass(ReactSixteenAdapter, [{
    key: 'createMountRenderer',
    value: function () {
      function createMountRenderer(options) {
        (0, _enzymeAdapterUtils.assertDomAvailable)('mount');
        if (FiberTags === null) {
          // Requires DOM.
          FiberTags = (0, _detectFiberTags2['default'])();
        }
        var attachTo = options.attachTo,
            hydrateIn = options.hydrateIn,
            wrappingComponentProps = options.wrappingComponentProps;

        var domNode = hydrateIn || attachTo || global.document.createElement('div');
        var instance = null;
        var adapter = this;
        return {
          render: function () {
            function render(el, context, callback) {
              return wrapAct(function () {
                if (instance === null) {
                  var type = el.type,
                      props = el.props,
                      ref = el.ref;

                  var wrapperProps = (0, _object2['default'])({
                    Component: type,
                    props: props,
                    wrappingComponentProps: wrappingComponentProps,
                    context: context
                  }, ref && { ref: ref });
                  var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, (0, _object2['default'])({}, options, { adapter: adapter }));
                  var wrappedEl = _react2['default'].createElement(ReactWrapperComponent, wrapperProps);
                  instance = hydrateIn ? _reactDom2['default'].hydrate(wrappedEl, domNode) : _reactDom2['default'].render(wrappedEl, domNode);
                  if (typeof callback === 'function') {
                    callback();
                  }
                } else {
                  instance.setChildProps(el.props, context, callback);
                }
              });
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              _reactDom2['default'].unmountComponentAtNode(domNode);
              instance = null;
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (!instance) {
                return null;
              }
              return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              var isErrorBoundary = function () {
                function isErrorBoundary(_ref) {
                  var elInstance = _ref.instance,
                      type = _ref.type;

                  if (is166 && type && type.getDerivedStateFromError) {
                    return true;
                  }
                  return elInstance && elInstance.componentDidCatch;
                }

                return isErrorBoundary;
              }();

              var _ref2 = nodeHierarchy.find(isErrorBoundary) || {},
                  catchingInstance = _ref2.instance,
                  catchingType = _ref2.type;

              (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, is166 ? catchingType : undefined);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event, mock) {
              var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
              var eventFn = _testUtils2['default'].Simulate[mappedEvent];
              if (!eventFn) {
                throw new TypeError('ReactWrapper::simulate() event \'' + String(event) + '\' does not exist');
              }
              eventFn(_nodeToHostNode(node), mock);
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          getWrappingComponentRenderer: function () {
            function getWrappingComponentRenderer() {
              return (0, _object2['default'])({}, this, (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
                toTree: function () {
                  function toTree(inst) {
                    return _toTree(inst._reactInternalFiber);
                  }

                  return toTree;
                }(),
                getMountWrapperInstance: function () {
                  function getMountWrapperInstance() {
                    return instance;
                  }

                  return getMountWrapperInstance;
                }()
              }));
            }

            return getWrappingComponentRenderer;
          }()
        };
      }

      return createMountRenderer;
    }()
  }, {
    key: 'createShallowRenderer',
    value: function () {
      function createShallowRenderer() /* options */{
        var adapter = this;
        var renderer = new _shallow2['default']();
        var isDOM = false;
        var cachedNode = null;

        var lastComponent = null;
        var wrappedComponent = null;

        // Wrap functional components on versions prior to 16.5,
        // to avoid inadvertently pass a `this` instance to it.
        var wrapFunctionalComponent = function () {
          function wrapFunctionalComponent(Component) {
            if (is165) {
              return Component;
            }

            if (lastComponent !== Component) {
              wrappedComponent = (0, _object2['default'])(function () {
                return Component.apply(undefined, arguments);
              }, // eslint-disable-line new-cap
              Component);
              lastComponent = Component;
            }
            return wrappedComponent;
          }

          return wrapFunctionalComponent;
        }();

        return {
          render: function () {
            function render(el, unmaskedContext) {
              var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                  _ref3$providerValues = _ref3.providerValues,
                  providerValues = _ref3$providerValues === undefined ? new Map() : _ref3$providerValues;

              cachedNode = el;
              /* eslint consistent-return: 0 */
              if (typeof el.type === 'string') {
                isDOM = true;
              } else if ((0, _reactIs.isContextProvider)(el)) {
                providerValues.set(el.type, el.props.value);
                var MockProvider = (0, _object2['default'])(function (props) {
                  return props.children;
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockProvider }));
                });
              } else if ((0, _reactIs.isContextConsumer)(el)) {
                var Provider = adapter.getProviderFromConsumer(el.type);
                var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
                var MockConsumer = (0, _object2['default'])(function (props) {
                  return props.children(value);
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockConsumer }));
                });
              } else {
                isDOM = false;
                var Component = el.type;


                var isStateful = Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
                );

                var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);

                if (!isStateful && (0, _reactIs.isMemo)(el.type)) {
                  var InnerComp = el.type.type;
                  return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                    return renderer.render((0, _object2['default'])({}, el, { type: wrapFunctionalComponent(InnerComp) }), context);
                  });
                }

                if (!isStateful && typeof Component === 'function') {
                  return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                    return renderer.render((0, _object2['default'])({}, el, { type: wrapFunctionalComponent(Component) }), context);
                  });
                }

                if (isStateful) {
                  // fix react bug; see implementation of `getEmptyStateValue`
                  var emptyStateValue = getEmptyStateValue();
                  if (emptyStateValue) {
                    Object.defineProperty(Component.prototype, 'state', {
                      configurable: true,
                      enumerable: true,
                      get: function () {
                        function get() {
                          return null;
                        }

                        return get;
                      }(),
                      set: function () {
                        function set(value) {
                          if (value !== emptyStateValue) {
                            Object.defineProperty(this, 'state', {
                              configurable: true,
                              enumerable: true,
                              value: value,
                              writable: true
                            });
                          }
                          return true;
                        }

                        return set;
                      }()
                    });
                  }
                }
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render(el, context);
                });
              }
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              renderer.unmount();
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (isDOM) {
                return elementToTree(cachedNode);
              }
              var output = renderer.getRenderOutput();
              return {
                nodeType: nodeTypeFromType(cachedNode.type),
                type: cachedNode.type,
                props: cachedNode.props,
                key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
                ref: cachedNode.ref,
                instance: renderer._instance,
                rendered: Array.isArray(output) ? flatten(output).map(function (el) {
                  return elementToTree(el);
                }) : elementToTree(output)
              };
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, is166 ? cachedNode.type : undefined);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event) {
              for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }

              var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];
              if (handler) {
                (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  // TODO(lmr): create/use synthetic events
                  // TODO(lmr): emulate React's event propagation
                  // ReactDOM.unstable_batchedUpdates(() => {
                  handler.apply(undefined, _toConsumableArray(args));
                  // });
                });
              }
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          checkPropTypes: function () {
            function checkPropTypes(typeSpecs, values, location, hierarchy) {
              return (0, _checkPropTypes3['default'])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
                return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
              });
            }

            return checkPropTypes;
          }()
        };
      }

      return createShallowRenderer;
    }()
  }, {
    key: 'createStringRenderer',
    value: function () {
      function createStringRenderer(options) {
        return {
          render: function () {
            function render(el, context) {
              if (options.context && (el.type.contextTypes || options.childContextTypes)) {
                var childContextTypes = (0, _object2['default'])({}, el.type.contextTypes || {}, options.childContextTypes);
                var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
                return _server2['default'].renderToStaticMarkup(_react2['default'].createElement(ContextWrapper));
              }
              return _server2['default'].renderToStaticMarkup(el);
            }

            return render;
          }()
        };
      }

      return createStringRenderer;
    }()

    // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'createRenderer',
    value: function () {
      function createRenderer(options) {
        switch (options.mode) {
          case _enzyme.EnzymeAdapter.MODES.MOUNT:
            return this.createMountRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.SHALLOW:
            return this.createShallowRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.STRING:
            return this.createStringRenderer(options);
          default:
            throw new Error('Enzyme Internal Error: Unrecognized mode: ' + String(options.mode));
        }
      }

      return createRenderer;
    }()
  }, {
    key: 'wrap',
    value: function () {
      function wrap(element) {
        return (0, _enzymeAdapterUtils.wrap)(element);
      }

      return wrap;
    }()

    // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'nodeToElement',
    value: function () {
      function nodeToElement(node) {
        if (!node || (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') return null;
        return _react2['default'].createElement(node.type, (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
      }

      return nodeToElement;
    }()
  }, {
    key: 'elementToNode',
    value: function () {
      function elementToNode(element) {
        return elementToTree(element);
      }

      return elementToNode;
    }()
  }, {
    key: 'nodeToHostNode',
    value: function () {
      function nodeToHostNode(node) {
        var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var nodes = _nodeToHostNode(node);
        if (Array.isArray(nodes) && !supportsArray) {
          return nodes[0];
        }
        return nodes;
      }

      return nodeToHostNode;
    }()
  }, {
    key: 'displayNameOfNode',
    value: function () {
      function displayNameOfNode(node) {
        if (!node) return null;
        var type = node.type,
            $$typeof = node.$$typeof;


        var nodeType = type || $$typeof;

        // newer node types may be undefined, so only test if the nodeType exists
        if (nodeType) {
          switch (nodeType) {
            case (is166 ? _reactIs.ConcurrentMode : _reactIs.AsyncMode) || NaN:
              return is166 ? 'ConcurrentMode' : 'AsyncMode';
            case _reactIs.Fragment || NaN:
              return 'Fragment';
            case _reactIs.StrictMode || NaN:
              return 'StrictMode';
            case _reactIs.Profiler || NaN:
              return 'Profiler';
            case _reactIs.Portal || NaN:
              return 'Portal';
            default:
          }
        }

        var $$typeofType = type && type.$$typeof;

        switch ($$typeofType) {
          case _reactIs.ContextConsumer || NaN:
            return 'ContextConsumer';
          case _reactIs.ContextProvider || NaN:
            return 'ContextProvider';
          case _reactIs.Memo || NaN:
            return (0, _enzymeAdapterUtils.displayNameOfNode)(type);
          case _reactIs.ForwardRef || NaN:
            {
              if (type.displayName) {
                return type.displayName;
              }
              var name = (0, _enzymeAdapterUtils.displayNameOfNode)({ type: type.render });
              return name ? 'ForwardRef(' + String(name) + ')' : 'ForwardRef';
            }
          default:
            return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
        }
      }

      return displayNameOfNode;
    }()
  }, {
    key: 'isValidElement',
    value: function () {
      function isValidElement(element) {
        return (0, _reactIs.isElement)(element);
      }

      return isValidElement;
    }()
  }, {
    key: 'isValidElementType',
    value: function () {
      function isValidElementType(object) {
        return !!object && (0, _reactIs.isValidElementType)(object);
      }

      return isValidElementType;
    }()
  }, {
    key: 'isFragment',
    value: function () {
      function isFragment(fragment) {
        return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
      }

      return isFragment;
    }()
  }, {
    key: 'isCustomComponent',
    value: function () {
      function isCustomComponent(type) {
        var fakeElement = makeFakeElement(type);
        return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement));
      }

      return isCustomComponent;
    }()
  }, {
    key: 'isContextConsumer',
    value: function () {
      function isContextConsumer(type) {
        return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
      }

      return isContextConsumer;
    }()
  }, {
    key: 'isCustomComponentElement',
    value: function () {
      function isCustomComponentElement(inst) {
        if (!inst || !this.isValidElement(inst)) {
          return false;
        }
        return this.isCustomComponent(inst.type);
      }

      return isCustomComponentElement;
    }()
  }, {
    key: 'getProviderFromConsumer',
    value: function () {
      function getProviderFromConsumer(Consumer) {
        // React stores references to the Provider on a Consumer differently across versions.
        if (Consumer) {
          var Provider = void 0;
          if (Consumer.Provider) {
            Provider = Consumer.Provider;
          } else if (Consumer._context) {
            Provider = Consumer._context.Provider;
          }
          if (Provider) {
            return Provider;
          }
        }
        throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
      }

      return getProviderFromConsumer;
    }()
  }, {
    key: 'createElement',
    value: function () {
      function createElement() {
        return _react2['default'].createElement.apply(_react2['default'], arguments);
      }

      return createElement;
    }()
  }, {
    key: 'wrapWithWrappingComponent',
    value: function () {
      function wrapWithWrappingComponent(node, options) {
        return {
          RootFinder: _enzymeAdapterUtils.RootFinder,
          node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react2['default'].createElement, node, options)
        };
      }

      return wrapWithWrappingComponent;
    }()
  }]);

  return ReactSixteenAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSixteenAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNpeHRlZW5BZGFwdGVyLmpzIl0sIm5hbWVzIjpbImlzMTY0IiwiVGVzdFV0aWxzIiwiU2ltdWxhdGUiLCJ0b3VjaFN0YXJ0IiwiaXMxNjUiLCJhdXhDbGljayIsImlzMTY2IiwiUmVhY3QiLCJ1bnN0YWJsZV9Bc3luY01vZGUiLCJpczE2OCIsImFjdCIsImhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZyIsInNlbXZlciIsInNhdGlzZmllcyIsInRlc3RSZW5kZXJlclZlcnNpb24iLCJGaWJlclRhZ3MiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwiZWxlbWVudFRvVHJlZSIsImNoaWxkcmVuIiwiY29udGFpbmVySW5mbyIsInByb3BzIiwibm9kZVR5cGUiLCJrZXkiLCJyZWYiLCJpbnN0YW5jZSIsInJlbmRlcmVkIiwidG9UcmVlIiwidm5vZGUiLCJ0YWciLCJIb3N0Um9vdCIsImNoaWxkcmVuVG9UcmVlIiwiY2hpbGQiLCJIb3N0UG9ydGFsIiwic3RhdGVOb2RlIiwibWVtb2l6ZWRQcm9wcyIsIkNsYXNzQ29tcG9uZW50IiwiRnVuY3Rpb25hbENvbXBvbmVudCIsIk1lbW9DbGFzcyIsImVsZW1lbnRUeXBlIiwiTWVtb1NGQyIsInJlbmRlcmVkTm9kZXMiLCJtYXAiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0UHJvdmlkZXIiLCJDb250ZXh0Q29uc3VtZXIiLCJQcm9maWxlciIsIkZvcndhcmRSZWYiLCJwZW5kaW5nUHJvcHMiLCJFcnJvciIsIm5vZGVUb0hvc3ROb2RlIiwiX25vZGUiLCJtYXBwZXIiLCJpdGVtIiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsImV2ZW50T3B0aW9ucyIsImFuaW1hdGlvbiIsInBvaW50ZXJFdmVudHMiLCJnZXRFbXB0eVN0YXRlVmFsdWUiLCJFbXB0eVN0YXRlIiwiQ29tcG9uZW50IiwidGVzdFJlbmRlcmVyIiwiU2hhbGxvd1JlbmRlcmVyIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsIl9pbnN0YW5jZSIsInN0YXRlIiwid3JhcEFjdCIsImZuIiwicmV0dXJuVmFsIiwiZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUiLCJQcm92aWRlciIsIl9jb250ZXh0IiwiX2RlZmF1bHRWYWx1ZSIsIl9jdXJyZW50VmFsdWUiLCJtYWtlRmFrZUVsZW1lbnQiLCIkJHR5cGVvZiIsIkVsZW1lbnQiLCJSZWFjdFNpeHRlZW5BZGFwdGVyIiwibGlmZWN5Y2xlcyIsIm9wdGlvbnMiLCJlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlIiwibGVnYWN5Q29udGV4dE1vZGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJvblNldFN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJzZXRTdGF0ZSIsInNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2FsbGVkQnlSZW5kZXJlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImF0dGFjaFRvIiwiaHlkcmF0ZUluIiwid3JhcHBpbmdDb21wb25lbnRQcm9wcyIsImRvbU5vZGUiLCJnbG9iYWwiLCJkb2N1bWVudCIsImFkYXB0ZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJ3cmFwcGVyUHJvcHMiLCJSZWFjdFdyYXBwZXJDb21wb25lbnQiLCJ3cmFwcGVkRWwiLCJoeWRyYXRlIiwic2V0Q2hpbGRQcm9wcyIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiZ2V0Tm9kZSIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsInNpbXVsYXRlRXJyb3IiLCJub2RlSGllcmFyY2h5Iiwicm9vdE5vZGUiLCJlcnJvciIsImlzRXJyb3JCb3VuZGFyeSIsImVsSW5zdGFuY2UiLCJjb21wb25lbnREaWRDYXRjaCIsImZpbmQiLCJjYXRjaGluZ0luc3RhbmNlIiwiY2F0Y2hpbmdUeXBlIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJ1bmRlZmluZWQiLCJzaW11bGF0ZUV2ZW50IiwiZXZlbnQiLCJtb2NrIiwibWFwcGVkRXZlbnQiLCJldmVudEZuIiwiVHlwZUVycm9yIiwiYmF0Y2hlZFVwZGF0ZXMiLCJnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyIiwiaW5zdCIsImdldE1vdW50V3JhcHBlckluc3RhbmNlIiwicmVuZGVyZXIiLCJpc0RPTSIsImNhY2hlZE5vZGUiLCJsYXN0Q29tcG9uZW50Iiwid3JhcHBlZENvbXBvbmVudCIsIndyYXBGdW5jdGlvbmFsQ29tcG9uZW50IiwidW5tYXNrZWRDb250ZXh0IiwicHJvdmlkZXJWYWx1ZXMiLCJNYXAiLCJzZXQiLCJ2YWx1ZSIsIk1vY2tQcm92aWRlciIsImdldFByb3ZpZGVyRnJvbUNvbnN1bWVyIiwiaGFzIiwiZ2V0IiwiTW9ja0NvbnN1bWVyIiwiaXNTdGF0ZWZ1bCIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsImNvbnRleHRUeXBlcyIsIklubmVyQ29tcCIsImVtcHR5U3RhdGVWYWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwib3V0cHV0IiwiZ2V0UmVuZGVyT3V0cHV0IiwiY29uY2F0IiwiYXJncyIsImhhbmRsZXIiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiaGllcmFyY2h5IiwiY2hpbGRDb250ZXh0VHlwZXMiLCJDb250ZXh0V3JhcHBlciIsIlJlYWN0RE9NU2VydmVyIiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJtb2RlIiwiRW56eW1lQWRhcHRlciIsIk1PREVTIiwiTU9VTlQiLCJjcmVhdGVNb3VudFJlbmRlcmVyIiwiU0hBTExPVyIsImNyZWF0ZVNoYWxsb3dSZW5kZXJlciIsIlNUUklORyIsImNyZWF0ZVN0cmluZ1JlbmRlcmVyIiwiZWxlbWVudCIsInN1cHBvcnRzQXJyYXkiLCJub2RlcyIsIkNvbmN1cnJlbnRNb2RlIiwiQXN5bmNNb2RlIiwiTmFOIiwiU3RyaWN0TW9kZSIsIiQkdHlwZW9mVHlwZSIsIk1lbW8iLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJvYmplY3QiLCJmcmFnbWVudCIsImZha2VFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJDb25zdW1lciIsIlJvb3RGaW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBcUJBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OzsrZUF4REE7O0FBR0E7O0FBRUE7O0FBR0E7OztBQWtEQSxJQUFNQSxRQUFRLENBQUMsQ0FBQ0MsdUJBQVVDLFFBQVYsQ0FBbUJDLFVBQW5DLEMsQ0FBK0M7QUFDL0MsSUFBTUMsUUFBUSxDQUFDLENBQUNILHVCQUFVQyxRQUFWLENBQW1CRyxRQUFuQyxDLENBQTZDO0FBQzdDLElBQU1DLFFBQVFGLFNBQVMsQ0FBQ0csbUJBQU1DLGtCQUE5QixDLENBQWtEO0FBQ2xELElBQU1DLFFBQVFILFNBQVMsT0FBT0wsdUJBQVVTLEdBQWpCLEtBQXlCLFVBQWhEOztBQUVBLElBQU1DLDhCQUE4QkMsb0JBQU9DLFNBQVAsQ0FBaUJDLGdCQUFqQixFQUFzQyxRQUF0QyxDQUFwQzs7QUFFQTtBQUNBLElBQUlDLFlBQVksSUFBaEI7O0FBRUEsU0FBU0Msb0JBQVQsQ0FBOEJDLGVBQTlCLEVBQStDO0FBQzdD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cUNBQVA7QUFDRDs7Ozs7Ozt5Q0FFeUJuRSxJLEVBQU1tRixPLEVBQVM7QUFDdkMsZUFBTztBQUNMd0gsb0RBREs7QUFFTDNNLGdCQUFNLG1EQUEwQlosbUJBQU0rRSxhQUFoQyxFQUErQ25FLElBQS9DLEVBQXFEbUYsT0FBckQ7QUFGRCxTQUFQO0FBSUQ7Ozs7Ozs7RUFsYitCZ0cscUI7O0FBcWJsQ3lCLE9BQU9DLE9BQVAsR0FBaUI1SCxtQkFBakIiLCJmaWxlIjoiUmVhY3RTaXh0ZWVuQWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgUmVhY3RET01TZXJ2ZXIgZnJvbSAncmVhY3QtZG9tL3NlcnZlcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCBTaGFsbG93UmVuZGVyZXIgZnJvbSAncmVhY3QtdGVzdC1yZW5kZXJlci9zaGFsbG93JztcbmltcG9ydCB7IHZlcnNpb24gYXMgdGVzdFJlbmRlcmVyVmVyc2lvbiB9IGZyb20gJ3JlYWN0LXRlc3QtcmVuZGVyZXIvcGFja2FnZS5qc29uJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IFRlc3RVdGlscyBmcm9tICdyZWFjdC1kb20vdGVzdC11dGlscyc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgY2hlY2tQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcyc7XG5pbXBvcnQge1xuICBBc3luY01vZGUsXG4gIENvbmN1cnJlbnRNb2RlLFxuICBDb250ZXh0Q29uc3VtZXIsXG4gIENvbnRleHRQcm92aWRlcixcbiAgRWxlbWVudCxcbiAgRm9yd2FyZFJlZixcbiAgRnJhZ21lbnQsXG4gIGlzQ29udGV4dENvbnN1bWVyLFxuICBpc0NvbnRleHRQcm92aWRlcixcbiAgaXNFbGVtZW50LFxuICBpc0ZvcndhcmRSZWYsXG4gIGlzTWVtbyxcbiAgaXNQb3J0YWwsXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcbiAgTWVtbyxcbiAgUG9ydGFsLFxuICBQcm9maWxlcixcbiAgU3RyaWN0TW9kZSxcbn0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IHsgRW56eW1lQWRhcHRlciB9IGZyb20gJ2VuenltZSc7XG5pbXBvcnQgeyB0eXBlT2ZOb2RlIH0gZnJvbSAnZW56eW1lL2J1aWxkL1V0aWxzJztcbmltcG9ydCB7XG4gIGRpc3BsYXlOYW1lT2ZOb2RlLFxuICBlbGVtZW50VG9UcmVlIGFzIHV0aWxFbGVtZW50VG9UcmVlLFxuICBub2RlVHlwZUZyb21UeXBlIGFzIHV0aWxOb2RlVHlwZUZyb21UeXBlLFxuICBtYXBOYXRpdmVFdmVudE5hbWVzLFxuICBwcm9wRnJvbUV2ZW50LFxuICBhc3NlcnREb21BdmFpbGFibGUsXG4gIHdpdGhTZXRTdGF0ZUFsbG93ZWQsXG4gIGNyZWF0ZVJlbmRlcldyYXBwZXIsXG4gIGNyZWF0ZU1vdW50V3JhcHBlcixcbiAgcHJvcHNXaXRoS2V5c0FuZFJlZixcbiAgZW5zdXJlS2V5T3JVbmRlZmluZWQsXG4gIHNpbXVsYXRlRXJyb3IsXG4gIHdyYXAsXG4gIGdldE1hc2tlZENvbnRleHQsXG4gIGdldENvbXBvbmVudFN0YWNrLFxuICBSb290RmluZGVyLFxuICBnZXROb2RlRnJvbVJvb3RGaW5kZXIsXG4gIHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQsXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcixcbn0gZnJvbSAnZW56eW1lLWFkYXB0ZXItdXRpbHMnO1xuaW1wb3J0IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIGZyb20gJy4vZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgnO1xuaW1wb3J0IGRldGVjdEZpYmVyVGFncyBmcm9tICcuL2RldGVjdEZpYmVyVGFncyc7XG5cbmNvbnN0IGlzMTY0ID0gISFUZXN0VXRpbHMuU2ltdWxhdGUudG91Y2hTdGFydDsgLy8gMTYuNCtcbmNvbnN0IGlzMTY1ID0gISFUZXN0VXRpbHMuU2ltdWxhdGUuYXV4Q2xpY2s7IC8vIDE2LjUrXG5jb25zdCBpczE2NiA9IGlzMTY1ICYmICFSZWFjdC51bnN0YWJsZV9Bc3luY01vZGU7IC8vIDE2LjYrXG5jb25zdCBpczE2OCA9IGlzMTY2ICYmIHR5cGVvZiBUZXN0VXRpbHMuYWN0ID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWcgPSBzZW12ZXIuc2F0aXNmaWVzKHRlc3RSZW5kZXJlclZlcnNpb24sICc8IDE2LjgnKTtcblxuLy8gTGF6aWx5IHBvcHVsYXRlZCBpZiBET00gaXMgYXZhaWxhYmxlLlxubGV0IEZpYmVyVGFncyA9IG51bGw7XG5cbmZ1bmN0aW9uIG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGVXaXRoU2libGluZykge1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBsZXQgbm9kZSA9IG5vZGVXaXRoU2libGluZztcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGFycmF5LnB1c2gobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFjayA9IFt7IGk6IDAsIGFycmF5OiBhcnIgfV07XG4gIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XG4gICAgd2hpbGUgKG4uaSA8IG4uYXJyYXkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbCA9IG4uYXJyYXlbbi5pXTtcbiAgICAgIG4uaSArPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobik7XG4gICAgICAgIHN0YWNrLnB1c2goeyBpOiAwLCBhcnJheTogZWwgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBub2RlVHlwZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFBvcnRhbCkge1xuICAgIHJldHVybiAncG9ydGFsJztcbiAgfVxuXG4gIHJldHVybiB1dGlsTm9kZVR5cGVGcm9tVHlwZSh0eXBlKTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudFRvVHJlZShlbCkge1xuICBpZiAoIWlzUG9ydGFsKGVsKSkge1xuICAgIHJldHVybiB1dGlsRWxlbWVudFRvVHJlZShlbCwgZWxlbWVudFRvVHJlZSk7XG4gIH1cblxuICBjb25zdCB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH0gPSBlbDtcbiAgY29uc3QgcHJvcHMgPSB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH07XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlVHlwZTogJ3BvcnRhbCcsXG4gICAgdHlwZTogUG9ydGFsLFxuICAgIHByb3BzLFxuICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoZWwua2V5KSxcbiAgICByZWY6IGVsLnJlZiB8fCBudWxsLFxuICAgIGluc3RhbmNlOiBudWxsLFxuICAgIHJlbmRlcmVkOiBlbGVtZW50VG9UcmVlKGVsLmNoaWxkcmVuKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9UcmVlKHZub2RlKSB7XG4gIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVE9ETyhsbXIpOiBJJ20gbm90IHJlYWxseSBzdXJlIEkgdW5kZXJzdGFuZCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHdoYXRcbiAgLy8gaSBzaG91bGQgYmUgZG9pbmcsIG9yIGlmIHRoaXMgaXMgYSBoYWNrIGZvciBzb21ldGhpbmcgaSdtIGRvaW5nIHdyb25nXG4gIC8vIHNvbWV3aGVyZSBlbHNlLiBTaG91bGQgdGFsayB0byBzZWJhc3RpYW4gYWJvdXQgdGhpcyBwZXJoYXBzXG4gIGNvbnN0IG5vZGUgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCh2bm9kZSk7XG4gIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICBjYXNlIEZpYmVyVGFncy5Ib3N0Um9vdDpcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcbiAgICBjYXNlIEZpYmVyVGFncy5Ib3N0UG9ydGFsOiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXRlTm9kZTogeyBjb250YWluZXJJbmZvIH0sXG4gICAgICAgIG1lbW9pemVkUHJvcHM6IGNoaWxkcmVuLFxuICAgICAgfSA9IG5vZGU7XG4gICAgICBjb25zdCBwcm9wcyA9IHsgY29udGFpbmVySW5mbywgY2hpbGRyZW4gfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAncG9ydGFsJyxcbiAgICAgICAgdHlwZTogUG9ydGFsLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIEZpYmVyVGFncy5DbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnY2xhc3MnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgRmliZXJUYWdzLkZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgRmliZXJUYWdzLk1lbW9DbGFzczpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnY2xhc3MnLFxuICAgICAgICB0eXBlOiBub2RlLmVsZW1lbnRUeXBlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZC5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgRmliZXJUYWdzLk1lbW9TRkM6IHtcbiAgICAgIGxldCByZW5kZXJlZE5vZGVzID0gZmxhdHRlbihub2RlQW5kU2libGluZ3NBcnJheShub2RlLmNoaWxkKS5tYXAodG9UcmVlKSk7XG4gICAgICBpZiAocmVuZGVyZWROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVuZGVyZWROb2RlcyA9IFtub2RlLm1lbW9pemVkUHJvcHMuY2hpbGRyZW5dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHR5cGU6IG5vZGUuZWxlbWVudFR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZE5vZGVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBGaWJlclRhZ3MuSG9zdENvbXBvbmVudDoge1xuICAgICAgbGV0IHJlbmRlcmVkTm9kZXMgPSBmbGF0dGVuKG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGUuY2hpbGQpLm1hcCh0b1RyZWUpKTtcbiAgICAgIGlmIChyZW5kZXJlZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW5kZXJlZE5vZGVzID0gW25vZGUubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbl07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2hvc3QnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWROb2RlcyxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgRmliZXJUYWdzLkhvc3RUZXh0OlxuICAgICAgcmV0dXJuIG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICBjYXNlIEZpYmVyVGFncy5GcmFnbWVudDpcbiAgICBjYXNlIEZpYmVyVGFncy5Nb2RlOlxuICAgIGNhc2UgRmliZXJUYWdzLkNvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIEZpYmVyVGFncy5Db250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XG4gICAgY2FzZSBGaWJlclRhZ3MuUHJvZmlsZXI6XG4gICAgY2FzZSBGaWJlclRhZ3MuRm9yd2FyZFJlZjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5wZW5kaW5nUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IHVua25vd24gbm9kZSB3aXRoIHRhZyAke25vZGUudGFnfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuVG9UcmVlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlQW5kU2libGluZ3NBcnJheShub2RlKTtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdG9UcmVlKGNoaWxkcmVuWzBdKTtcbiAgfVxuICByZXR1cm4gZmxhdHRlbihjaGlsZHJlbi5tYXAodG9UcmVlKSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb0hvc3ROb2RlKF9ub2RlKSB7XG4gIC8vIE5PVEUobG1yKTogbm9kZSBjb3VsZCBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAvLyB3aGljaCB3b250IGhhdmUgYW4gaW5zdGFuY2UgcHJvcCwgYnV0IHdlIGNhbiBnZXQgdGhlXG4gIC8vIGhvc3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggaXRzIHJldHVybiB2YWx1ZSBhdCB0aGF0IHBvaW50LlxuICAvLyBBbHRob3VnaCB0aGlzIGJyZWFrcyBkb3duIGlmIHRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXksXG4gIC8vIGFzIGlzIHBvc3NpYmxlIHdpdGggUmVhY3QgMTYuXG4gIGxldCBub2RlID0gX25vZGU7XG4gIHdoaWxlIChub2RlICYmICFBcnJheS5pc0FycmF5KG5vZGUpICYmIG5vZGUuaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICBub2RlID0gbm9kZS5yZW5kZXJlZDtcbiAgfVxuICAvLyBpZiB0aGUgU0ZDIHJldHVybmVkIG51bGwgZWZmZWN0aXZlbHksIHRoZXJlIGlzIG5vIGhvc3Qgbm9kZS5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtYXBwZXIgPSAoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtICYmIGl0ZW0uaW5zdGFuY2UpIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShpdGVtLmluc3RhbmNlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5tYXAobWFwcGVyKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlLnJlbmRlcmVkKSAmJiBub2RlLm5vZGVUeXBlID09PSAnY2xhc3MnKSB7XG4gICAgcmV0dXJuIG5vZGUucmVuZGVyZWQubWFwKG1hcHBlcik7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcihub2RlKTtcbn1cblxuY29uc3QgZXZlbnRPcHRpb25zID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIHBvaW50ZXJFdmVudHM6IGlzMTY0LFxuICBhdXhDbGljazogaXMxNjUsXG59O1xuXG5mdW5jdGlvbiBnZXRFbXB0eVN0YXRlVmFsdWUoKSB7XG4gIC8vIHRoaXMgaGFuZGxlcyBhIGJ1ZyBpbiBSZWFjdCAxNi4wIC0gMTYuMlxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2NvbW1pdC8zOWJlODM1NjVjNjVmOWM1MjIxNTBlNTIzNzUxNjc1NjhhMmExNDU5XG4gIC8vIGFsc28gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExOTY1XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb25cbiAgY2xhc3MgRW1wdHlTdGF0ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRlc3RSZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgdGVzdFJlbmRlcmVyLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KEVtcHR5U3RhdGUpKTtcbiAgcmV0dXJuIHRlc3RSZW5kZXJlci5faW5zdGFuY2Uuc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3QoZm4pIHtcbiAgaWYgKCFpczE2OCkge1xuICAgIHJldHVybiBmbigpO1xuICB9XG4gIGxldCByZXR1cm5WYWw7XG4gIFRlc3RVdGlscy5hY3QoKCkgPT4geyByZXR1cm5WYWwgPSBmbigpOyB9KTtcbiAgcmV0dXJuIHJldHVyblZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUoUHJvdmlkZXIpIHtcbiAgLy8gUmVhY3Qgc3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIFByb3ZpZGVyJ3MgZGVmYXVsdFZhbHVlIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cbiAgaWYgKCdfZGVmYXVsdFZhbHVlJyBpbiBQcm92aWRlci5fY29udGV4dCkge1xuICAgIHJldHVybiBQcm92aWRlci5fY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuICB9XG4gIGlmICgnX2N1cnJlbnRWYWx1ZScgaW4gUHJvdmlkZXIuX2NvbnRleHQpIHtcbiAgICByZXR1cm4gUHJvdmlkZXIuX2NvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0VuenltZSBJbnRlcm5hbCBFcnJvcjogY2Fu4oCZdCBmaWd1cmUgb3V0IGhvdyB0byBnZXQgUHJvdmlkZXLigJlzIGRlZmF1bHQgdmFsdWUnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZha2VFbGVtZW50KHR5cGUpIHtcbiAgcmV0dXJuIHsgJCR0eXBlb2Y6IEVsZW1lbnQsIHR5cGUgfTtcbn1cblxuY2xhc3MgUmVhY3RTaXh0ZWVuQWRhcHRlciBleHRlbmRzIEVuenltZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgbGlmZWN5Y2xlcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGU6IHRydWUsIC8vIFRPRE86IHJlbW92ZSwgc2VtdmVyLW1ham9yXG4gICAgICBsZWdhY3lDb250ZXh0TW9kZTogJ3BhcmVudCcsXG4gICAgICBsaWZlY3ljbGVzOiB7XG4gICAgICAgIC4uLmxpZmVjeWNsZXMsXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZToge1xuICAgICAgICAgIG9uU2V0U3RhdGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczoge1xuICAgICAgICAgIGhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZyxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU6IHRydWUsXG4gICAgICAgIHNldFN0YXRlOiB7XG4gICAgICAgICAgc2tpcHNDb21wb25lbnREaWRVcGRhdGVPbk51bGxpc2g6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGdldENoaWxkQ29udGV4dDoge1xuICAgICAgICAgIGNhbGxlZEJ5UmVuZGVyZXI6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IGlzMTY2LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlTW91bnRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgYXNzZXJ0RG9tQXZhaWxhYmxlKCdtb3VudCcpO1xuICAgIGlmIChGaWJlclRhZ3MgPT09IG51bGwpIHtcbiAgICAgIC8vIFJlcXVpcmVzIERPTS5cbiAgICAgIEZpYmVyVGFncyA9IGRldGVjdEZpYmVyVGFncygpO1xuICAgIH1cbiAgICBjb25zdCB7IGF0dGFjaFRvLCBoeWRyYXRlSW4sIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZG9tTm9kZSA9IGh5ZHJhdGVJbiB8fCBhdHRhY2hUbyB8fCBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGV0IGluc3RhbmNlID0gbnVsbDtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gd3JhcEFjdCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYgfSA9IGVsO1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlclByb3BzID0ge1xuICAgICAgICAgICAgICBDb21wb25lbnQ6IHR5cGUsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICB3cmFwcGluZ0NvbXBvbmVudFByb3BzLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAuLi4ocmVmICYmIHsgcmVmIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IFJlYWN0V3JhcHBlckNvbXBvbmVudCA9IGNyZWF0ZU1vdW50V3JhcHBlcihlbCwgeyAuLi5vcHRpb25zLCBhZGFwdGVyIH0pO1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVsID0gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdFdyYXBwZXJDb21wb25lbnQsIHdyYXBwZXJQcm9wcyk7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IGh5ZHJhdGVJblxuICAgICAgICAgICAgICA/IFJlYWN0RE9NLmh5ZHJhdGUod3JhcHBlZEVsLCBkb21Ob2RlKVxuICAgICAgICAgICAgICA6IFJlYWN0RE9NLnJlbmRlcih3cmFwcGVkRWwsIGRvbU5vZGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRDaGlsZFByb3BzKGVsLnByb3BzLCBjb250ZXh0LCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKGRvbU5vZGUpO1xuICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXROb2RlRnJvbVJvb3RGaW5kZXIoXG4gICAgICAgICAgYWRhcHRlci5pc0N1c3RvbUNvbXBvbmVudCxcbiAgICAgICAgICB0b1RyZWUoaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxGaWJlciksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xuICAgICAgICBjb25zdCBpc0Vycm9yQm91bmRhcnkgPSAoeyBpbnN0YW5jZTogZWxJbnN0YW5jZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgaWYgKGlzMTY2ICYmIHR5cGUgJiYgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWxJbnN0YW5jZSAmJiBlbEluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbnN0YW5jZTogY2F0Y2hpbmdJbnN0YW5jZSxcbiAgICAgICAgICB0eXBlOiBjYXRjaGluZ1R5cGUsXG4gICAgICAgIH0gPSBub2RlSGllcmFyY2h5LmZpbmQoaXNFcnJvckJvdW5kYXJ5KSB8fCB7fTtcblxuICAgICAgICBzaW11bGF0ZUVycm9yKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGNhdGNoaW5nSW5zdGFuY2UsXG4gICAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgICAgbm9kZUhpZXJhcmNoeSxcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxuICAgICAgICAgIGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUsXG4gICAgICAgICAgaXMxNjYgPyBjYXRjaGluZ1R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFdmVudChub2RlLCBldmVudCwgbW9jaykge1xuICAgICAgICBjb25zdCBtYXBwZWRFdmVudCA9IG1hcE5hdGl2ZUV2ZW50TmFtZXMoZXZlbnQsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGV2ZW50Rm4gPSBUZXN0VXRpbHMuU2ltdWxhdGVbbWFwcGVkRXZlbnRdO1xuICAgICAgICBpZiAoIWV2ZW50Rm4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWFjdFdyYXBwZXI6OnNpbXVsYXRlKCkgZXZlbnQgJyR7ZXZlbnR9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50Rm4obm9kZVRvSG9zdE5vZGUobm9kZSksIG1vY2spO1xuICAgICAgfSxcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAvLyByZXR1cm4gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZm4pO1xuICAgICAgfSxcbiAgICAgIGdldFdyYXBwaW5nQ29tcG9uZW50UmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAuLi5nZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIoe1xuICAgICAgICAgICAgdG9UcmVlOiBpbnN0ID0+IHRvVHJlZShpbnN0Ll9yZWFjdEludGVybmFsRmliZXIpLFxuICAgICAgICAgICAgZ2V0TW91bnRXcmFwcGVySW5zdGFuY2U6ICgpID0+IGluc3RhbmNlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlU2hhbGxvd1JlbmRlcmVyKC8qIG9wdGlvbnMgKi8pIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgICBsZXQgaXNET00gPSBmYWxzZTtcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XG5cbiAgICBsZXQgbGFzdENvbXBvbmVudCA9IG51bGw7XG4gICAgbGV0IHdyYXBwZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgLy8gV3JhcCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgb24gdmVyc2lvbnMgcHJpb3IgdG8gMTYuNSxcbiAgICAvLyB0byBhdm9pZCBpbmFkdmVydGVudGx5IHBhc3MgYSBgdGhpc2AgaW5zdGFuY2UgdG8gaXQuXG4gICAgY29uc3Qgd3JhcEZ1bmN0aW9uYWxDb21wb25lbnQgPSAoQ29tcG9uZW50KSA9PiB7XG4gICAgICBpZiAoaXMxNjUpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RDb21wb25lbnQgIT09IENvbXBvbmVudCkge1xuICAgICAgICB3cmFwcGVkQ29tcG9uZW50ID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAoLi4uYXJncykgPT4gQ29tcG9uZW50KC4uLmFyZ3MpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICk7XG4gICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZENvbXBvbmVudDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgdW5tYXNrZWRDb250ZXh0LCB7XG4gICAgICAgIHByb3ZpZGVyVmFsdWVzID0gbmV3IE1hcCgpLFxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNhY2hlZE5vZGUgPSBlbDtcbiAgICAgICAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwICovXG4gICAgICAgIGlmICh0eXBlb2YgZWwudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc0RPTSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0UHJvdmlkZXIoZWwpKSB7XG4gICAgICAgICAgcHJvdmlkZXJWYWx1ZXMuc2V0KGVsLnR5cGUsIGVsLnByb3BzLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBNb2NrUHJvdmlkZXIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcHJvcHMgPT4gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBlbC50eXBlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyZXIucmVuZGVyKHsgLi4uZWwsIHR5cGU6IE1vY2tQcm92aWRlciB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0Q29uc3VtZXIoZWwpKSB7XG4gICAgICAgICAgY29uc3QgUHJvdmlkZXIgPSBhZGFwdGVyLmdldFByb3ZpZGVyRnJvbUNvbnN1bWVyKGVsLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXJWYWx1ZXMuaGFzKFByb3ZpZGVyKVxuICAgICAgICAgICAgPyBwcm92aWRlclZhbHVlcy5nZXQoUHJvdmlkZXIpXG4gICAgICAgICAgICA6IGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKTtcbiAgICAgICAgICBjb25zdCBNb2NrQ29uc3VtZXIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcHJvcHMgPT4gcHJvcHMuY2hpbGRyZW4odmFsdWUpLFxuICAgICAgICAgICAgZWwudHlwZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcih7IC4uLmVsLCB0eXBlOiBNb2NrQ29uc3VtZXIgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzRE9NID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQgfSA9IGVsO1xuXG4gICAgICAgICAgY29uc3QgaXNTdGF0ZWZ1bCA9IENvbXBvbmVudC5wcm90b3R5cGUgJiYgKFxuICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XG4gICAgICAgICAgICB8fCBBcnJheS5pc0FycmF5KENvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycykgLy8gZmFsbGJhY2sgZm9yIGNyZWF0ZUNsYXNzIGNvbXBvbmVudHNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgICAgICAgIGlmICghaXNTdGF0ZWZ1bCAmJiBpc01lbW8oZWwudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IElubmVyQ29tcCA9IGVsLnR5cGUudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgeyAuLi5lbCwgdHlwZTogd3JhcEZ1bmN0aW9uYWxDb21wb25lbnQoSW5uZXJDb21wKSB9LFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc1N0YXRlZnVsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgeyAuLi5lbCwgdHlwZTogd3JhcEZ1bmN0aW9uYWxDb21wb25lbnQoQ29tcG9uZW50KSB9LFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RhdGVmdWwpIHtcbiAgICAgICAgICAgIC8vIGZpeCByZWFjdCBidWc7IHNlZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0RW1wdHlTdGF0ZVZhbHVlYFxuICAgICAgICAgICAgY29uc3QgZW1wdHlTdGF0ZVZhbHVlID0gZ2V0RW1wdHlTdGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZW1wdHlTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCAnc3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZW1wdHlTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcihlbCwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgcmVuZGVyZXIudW5tb3VudCgpO1xuICAgICAgfSxcbiAgICAgIGdldE5vZGUoKSB7XG4gICAgICAgIGlmIChpc0RPTSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJlbmRlcmVyLmdldFJlbmRlck91dHB1dCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGVUeXBlOiBub2RlVHlwZUZyb21UeXBlKGNhY2hlZE5vZGUudHlwZSksXG4gICAgICAgICAgdHlwZTogY2FjaGVkTm9kZS50eXBlLFxuICAgICAgICAgIHByb3BzOiBjYWNoZWROb2RlLnByb3BzLFxuICAgICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoY2FjaGVkTm9kZS5rZXkpLFxuICAgICAgICAgIHJlZjogY2FjaGVkTm9kZS5yZWYsXG4gICAgICAgICAgaW5zdGFuY2U6IHJlbmRlcmVyLl9pbnN0YW5jZSxcbiAgICAgICAgICByZW5kZXJlZDogQXJyYXkuaXNBcnJheShvdXRwdXQpXG4gICAgICAgICAgICA/IGZsYXR0ZW4ob3V0cHV0KS5tYXAoZWwgPT4gZWxlbWVudFRvVHJlZShlbCkpXG4gICAgICAgICAgICA6IGVsZW1lbnRUb1RyZWUob3V0cHV0KSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xuICAgICAgICBzaW11bGF0ZUVycm9yKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlbmRlcmVyLl9pbnN0YW5jZSxcbiAgICAgICAgICBjYWNoZWROb2RlLFxuICAgICAgICAgIG5vZGVIaWVyYXJjaHkuY29uY2F0KGNhY2hlZE5vZGUpLFxuICAgICAgICAgIG5vZGVUeXBlRnJvbVR5cGUsXG4gICAgICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSxcbiAgICAgICAgICBpczE2NiA/IGNhY2hlZE5vZGUudHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUV2ZW50KG5vZGUsIGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBub2RlLnByb3BzW3Byb3BGcm9tRXZlbnQoZXZlbnQsIGV2ZW50T3B0aW9ucyldO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETyhsbXIpOiBjcmVhdGUvdXNlIHN5bnRoZXRpYyBldmVudHNcbiAgICAgICAgICAgIC8vIFRPRE8obG1yKTogZW11bGF0ZSBSZWFjdCdzIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAvLyBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiYXRjaGVkVXBkYXRlcyhmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgLy8gcmV0dXJuIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZuKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGhpZXJhcmNoeSkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgdHlwZVNwZWNzLFxuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBkaXNwbGF5TmFtZU9mTm9kZShjYWNoZWROb2RlKSxcbiAgICAgICAgICAoKSA9PiBnZXRDb21wb25lbnRTdGFjayhoaWVyYXJjaHkuY29uY2F0KFtjYWNoZWROb2RlXSkpLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlU3RyaW5nUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXIoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCAmJiAoZWwudHlwZS5jb250ZXh0VHlwZXMgfHwgb3B0aW9ucy5jaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIC4uLihlbC50eXBlLmNvbnRleHRUeXBlcyB8fCB7fSksXG4gICAgICAgICAgICAuLi5vcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgQ29udGV4dFdyYXBwZXIgPSBjcmVhdGVSZW5kZXJXcmFwcGVyKGVsLCBjb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcyk7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFdyYXBwZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoZWwpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHJvdmlkZWQgYSBiYWcgb2Ygb3B0aW9ucywgcmV0dXJuIGFuIGBFbnp5bWVSZW5kZXJlcmAuIFNvbWUgb3B0aW9ucyBjYW4gYmUgaW1wbGVtZW50YXRpb25cbiAgLy8gc3BlY2lmaWMsIGxpa2UgYGF0dGFjaGAgZXRjLiBmb3IgUmVhY3QsIGJ1dCBub3QgcGFydCBvZiB0aGlzIGludGVyZmFjZSBleHBsaWNpdGx5LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgc3dpdGNoIChvcHRpb25zLm1vZGUpIHtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5NT1VOVDogcmV0dXJuIHRoaXMuY3JlYXRlTW91bnRSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5TSEFMTE9XOiByZXR1cm4gdGhpcy5jcmVhdGVTaGFsbG93UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuU1RSSU5HOiByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmdSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiBVbnJlY29nbml6ZWQgbW9kZTogJHtvcHRpb25zLm1vZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgd3JhcChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHdyYXAoZWxlbWVudCk7XG4gIH1cblxuICAvLyBjb252ZXJ0cyBhbiBSU1ROb2RlIHRvIHRoZSBjb3JyZXNwb25kaW5nIEpTWCBQcmFnbWEgRWxlbWVudC4gVGhpcyB3aWxsIGJlIG5lZWRlZFxuICAvLyBpbiBvcmRlciB0byBpbXBsZW1lbnQgdGhlIGBXcmFwcGVyLm1vdW50KClgIGFuZCBgV3JhcHBlci5zaGFsbG93KClgIG1ldGhvZHMsIGJ1dCBzaG91bGRcbiAgLy8gYmUgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZCBmb3IgcGVvcGxlIHRvIGltcGxlbWVudC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgbm9kZVRvRWxlbWVudChub2RlKSB7XG4gICAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQobm9kZS50eXBlLCBwcm9wc1dpdGhLZXlzQW5kUmVmKG5vZGUpKTtcbiAgfVxuXG4gIGVsZW1lbnRUb05vZGUoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGVsZW1lbnQpO1xuICB9XG5cbiAgbm9kZVRvSG9zdE5vZGUobm9kZSwgc3VwcG9ydHNBcnJheSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBub2RlVG9Ib3N0Tm9kZShub2RlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykgJiYgIXN1cHBvcnRzQXJyYXkpIHtcbiAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyB0eXBlLCAkJHR5cGVvZiB9ID0gbm9kZTtcblxuICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSB8fCAkJHR5cGVvZjtcblxuICAgIC8vIG5ld2VyIG5vZGUgdHlwZXMgbWF5IGJlIHVuZGVmaW5lZCwgc28gb25seSB0ZXN0IGlmIHRoZSBub2RlVHlwZSBleGlzdHNcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAoaXMxNjYgPyBDb25jdXJyZW50TW9kZSA6IEFzeW5jTW9kZSkgfHwgTmFOOiByZXR1cm4gaXMxNjYgPyAnQ29uY3VycmVudE1vZGUnIDogJ0FzeW5jTW9kZSc7XG4gICAgICAgIGNhc2UgRnJhZ21lbnQgfHwgTmFOOiByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBTdHJpY3RNb2RlIHx8IE5hTjogcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICAgICAgY2FzZSBQcm9maWxlciB8fCBOYU46IHJldHVybiAnUHJvZmlsZXInO1xuICAgICAgICBjYXNlIFBvcnRhbCB8fCBOYU46IHJldHVybiAnUG9ydGFsJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXIgfHwgTmFOOiByZXR1cm4gJ0NvbnRleHRDb25zdW1lcic7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlciB8fCBOYU46IHJldHVybiAnQ29udGV4dFByb3ZpZGVyJztcbiAgICAgIGNhc2UgTWVtbyB8fCBOYU46IHJldHVybiBkaXNwbGF5TmFtZU9mTm9kZSh0eXBlKTtcbiAgICAgIGNhc2UgRm9yd2FyZFJlZiB8fCBOYU46IHtcbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiB0eXBlLnJlbmRlciB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBgRm9yd2FyZFJlZigke25hbWV9KWAgOiAnRm9yd2FyZFJlZic7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZGlzcGxheU5hbWVPZk5vZGUobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCk7XG4gIH1cblxuICBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhb2JqZWN0ICYmIGlzVmFsaWRFbGVtZW50VHlwZShvYmplY3QpO1xuICB9XG5cbiAgaXNGcmFnbWVudChmcmFnbWVudCkge1xuICAgIHJldHVybiB0eXBlT2ZOb2RlKGZyYWdtZW50KSA9PT0gRnJhZ21lbnQ7XG4gIH1cblxuICBpc0N1c3RvbUNvbXBvbmVudCh0eXBlKSB7XG4gICAgY29uc3QgZmFrZUVsZW1lbnQgPSBtYWtlRmFrZUVsZW1lbnQodHlwZSk7XG4gICAgcmV0dXJuICEhdHlwZSAmJiAoXG4gICAgICB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgfHwgaXNGb3J3YXJkUmVmKGZha2VFbGVtZW50KVxuICAgICAgfHwgaXNDb250ZXh0UHJvdmlkZXIoZmFrZUVsZW1lbnQpXG4gICAgICB8fCBpc0NvbnRleHRDb25zdW1lcihmYWtlRWxlbWVudClcbiAgICApO1xuICB9XG5cbiAgaXNDb250ZXh0Q29uc3VtZXIodHlwZSkge1xuICAgIHJldHVybiAhIXR5cGUgJiYgaXNDb250ZXh0Q29uc3VtZXIobWFrZUZha2VFbGVtZW50KHR5cGUpKTtcbiAgfVxuXG4gIGlzQ3VzdG9tQ29tcG9uZW50RWxlbWVudChpbnN0KSB7XG4gICAgaWYgKCFpbnN0IHx8ICF0aGlzLmlzVmFsaWRFbGVtZW50KGluc3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzQ3VzdG9tQ29tcG9uZW50KGluc3QudHlwZSk7XG4gIH1cblxuICBnZXRQcm92aWRlckZyb21Db25zdW1lcihDb25zdW1lcikge1xuICAgIC8vIFJlYWN0IHN0b3JlcyByZWZlcmVuY2VzIHRvIHRoZSBQcm92aWRlciBvbiBhIENvbnN1bWVyIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cbiAgICBpZiAoQ29uc3VtZXIpIHtcbiAgICAgIGxldCBQcm92aWRlcjtcbiAgICAgIGlmIChDb25zdW1lci5Qcm92aWRlcikge1xuICAgICAgICAoeyBQcm92aWRlciB9ID0gQ29uc3VtZXIpO1xuICAgICAgfSBlbHNlIGlmIChDb25zdW1lci5fY29udGV4dCkge1xuICAgICAgICAoeyBQcm92aWRlciB9ID0gQ29uc3VtZXIuX2NvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKFByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBQcm92aWRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IGNhbuKAmXQgZmlndXJlIG91dCBob3cgdG8gZ2V0IFByb3ZpZGVyIGZyb20gQ29uc3VtZXInKTtcbiAgfVxuXG4gIGNyZWF0ZUVsZW1lbnQoLi4uYXJncykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLmFyZ3MpO1xuICB9XG5cbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFJvb3RGaW5kZXIsXG4gICAgICBub2RlOiB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KFJlYWN0LmNyZWF0ZUVsZW1lbnQsIG5vZGUsIG9wdGlvbnMpLFxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNpeHRlZW5BZGFwdGVyO1xuIl19
//# sourceMappingURL=ReactSixteenAdapter.js.map